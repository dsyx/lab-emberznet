// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include EMBER_AF_API_EMBER_TYPES
#include "app/util/ezsp/ezsp-enum.h"
#include "hal/hal.h"
#include "app/util/ezsp/ezsp-frame-utilities.h"
#include EMBER_AF_API_HAL
#include EMBER_AF_API_SIM_EEPROM
#include EMBER_AF_API_ZIGBEE_PRO
#include EMBER_AF_API_STACK


void emberAfCounterHandler(EmberCounterType type, EmberCounterInfo info)
{
}


/** @brief NCP Application hook callback for green power messages.
 *
 * This function is called by the application hook plugin to allow
 * user to take an action gpd message is received. The return code
 * true indicate the user handled the message and false allows the
 * stack to handle it.
 *
 * @param status                     Ver.: always
 * @param gpdLink                    Ver.: always
 * @param sequenceNumber             Ver.: always
 * @param *addr                      Ver.: always
 * @param gpdfSecurityLevel          Ver.: always
 * @param gpdfSecurityKeyType        Ver.: always
 * @param autoCommissioning          Ver.: always
 * @param rxAfterTx                  Ver.: always
 * @param gpdSecurityFrameCounter    Ver.: always
 * @param gpdCommandId               Ver.: always
 * @param mic                        Ver.: always
 * @param proxyTableIndex            Ver.: always
 * @param gpdCommandPayloadLength    Ver.: always
 * @param *gpdCommandPayload         Ver.: always
 */
bool emberAfNcpGpepIncomingMessageHandler(GP_PARAMS)
{
  // return false so that stack will handle it, return true
  // if the message has been handled by user.
  return false;
}



void emberDebugHandler(EmberMessageBuffer message)
{
}



/** @brief Called when emberTrustCenterJoinHandler is called from the stack.
 *
 * The NCP will perform initial processing based on the current
 * ::EZSP_TRUST_CENTER_POLICY value and will pass this callback to the
 * NCP application. Implementations of this callback should return the
 * ::EmberJoinDecision value that will dictate the behavior of the trust center
 * in response to the new device joining or rejoining to the network.
 *
 * See documentation on the stack emberTrustCenterJoinHandler callback
 * for more information.
 *
 * @param newNodeId The node ID of the device wishing to join.
 * @param newNodeEui64 The EUI64 of the device wishing to join.
 * @param status The ::EmberUpdateDevice status indicating whether the
 * device is joining/rejoining or leaving, and whether the join/rejoin is
 * secure (using network encryption) or a trust center rejoin.
 * @param parentOfNewNode The node ID of the parent of device wishing to join.
 * @param decisionId The ::EzspDecisionId that the NCP is currently using
 * as set by the HOST application.
 * @param joinDecision The current ::EmberJoinDecision that the NCP has chosen
 * based on the ::EzspDecisionId for the ::EZSP_TRUST_CENTER_POLICY as set by the
 * HOST application. Implementations of this callback may want to return a
 * different value based on their desired security.
 *
 * @return An ::EmberJoinDecision value that will dictate the behavior of the
 * trust center in response to the new device joining or rejoining to
 * the network.
 */
EmberJoinDecision emberAfPluginEzspSecurityTrustCenterJoinCallback(EmberNodeId newNodeId,
                                                                   const EmberEUI64 newNodeEui64,
                                                                   EmberDeviceUpdate status,
                                                                   EmberNodeId parentOfNewNode,
                                                                   EzspDecisionId decisionId,
                                                                   EmberJoinDecision joinDecision)
{
  return joinDecision;
}



/**
 * @brief Called whenever the radio is powered on.
 */
void halRadioPowerUpHandler(void)
{
}


/**
 * @brief Called whenever the radio is powered off.
 */
void halRadioPowerDownHandler(void)
{
}


/**
 * @brief Called whenever the microcontroller enters/exits a idle/sleep mode
 *
 * @param enter        True if entering idle/sleep, False if exiting
 * @param sleepMode    Idle/sleep mode
 */
void halSleepCallback(boolean enter, SleepModes sleepMode)
{
}



/** @brief Performs any additional initialization required at system startup.
 *
 * This function is called when the application starts and can be used to
 * perform any additional initialization required at system startup.
 */
void emberAfMainInitCallback(void)
{
}


/** @brief Called in each iteration of the main application loop.
 *
 * This function is called in each iteration of the main application loop and
 * can be used to perform periodic functions. The frequency with which this
 * function is called depends on how quickly the main loop runs. If the
 * application blocks at any time during the main loop, this function will not
 * be called until execution resumes.
 */
void emberAfMainTickCallback(void)
{
}



void emberSetOrGetEzspTokenCommandHandler(bool isSet)
{
  appendInt8u(EMBER_INVALID_CALL);
}



/** @brief The Simulated EEPROM callback function, implemented by the
 * application.
 *
 * @param status  An ::EmberStatus error code indicating one of the conditions
 * described below.
 *
 * This callback will report an EmberStatus of
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN whenever a token is set and a page needs
 * to be erased. If the main application loop does not periodically
 * call halSimEepromErasePage(), it is best to then erase a page in
 * response to ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_ERASE_PAGE_RED
 * when the pages <i>must</i> be erased to prevent data loss.
 * halSimEepromErasePage() needs to be called until it returns 0 to indicate
 * there are no more pages that need to be erased.  Ignoring
 * this indication and not erasing the pages will cause dropping the new data
 * trying to be written.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_FULL when
 * the new data cannot be written due to unerased pages.  <b>Not erasing
 * pages regularly, not erasing in response to
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN, or not erasing in response to
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_RED will cause
 * ::EMBER_SIM_EEPROM_FULL and the new data will be lost!.</b>  Any future
 * write attempts will be lost as well.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_REPAIRING
 * when the Simulated EEPROM needs to repair itself. While there's nothing
 * for an app to do when the SimEE is going to repair itself (SimEE has to
 * be fully functional for the rest of the system to work), alert the
 * application to the fact that repairing is occurring. There are debugging
 * scenarios where an app might want to know that repairing is happening;
 * such as monitoring frequency.
 * @note  Common situations will trigger an expected repair, such as using
 *        a new chip or changing token definitions.
 *
 * If the callback ever reports the status ::EMBER_ERR_FLASH_WRITE_INHIBITED or
 * ::EMBER_ERR_FLASH_VERIFY_FAILED, a catastrophic failure has occurred in
 * flash writing, meaning either the address being written is not empty or the
 * write itself has failed. If ::EMBER_ERR_FLASH_WRITE_INHIBITED is
 * encountered, the function ::halInternalSimEeRepair(false) should be called
 * and the chip should then be reset to allow proper initialization to recover.
 * If ::EMBER_ERR_FLASH_VERIFY_FAILED is encountered the Simulated EEPROM (and
 * tokens) on the specific chip with this error should not be trusted anymore.
 *
 */
void halSimEepromCallback(EmberStatus status)
{
  switch (status) {
  case EMBER_SIM_EEPROM_ERASE_PAGE_GREEN:
    //SimEE is asking for one page to be erased.
    halSimEepromErasePage();
    break;
  case EMBER_SIM_EEPROM_ERASE_PAGE_RED:
  case EMBER_SIM_EEPROM_FULL:
  { //SimEE says we're out of room!  Erase all pages now or data
    //currently being written will be dropped.
    if(halSimEepromPagesRemainingToBeErased() > 0) {
      //If there is at least one HW page to erase, loop over ErasePage until
      //all HW pages are erased.  Without this explicit check before
      //ErasePage, when halSimEepromErasePage() returns 0 the code wont
      //know if a page was actually erased or not and properly break out.
      while(halSimEepromErasePage()) {
      }
      // A fresh virtual page now exists to use
      break;
    }
    //If there are still pages to erase, then we have a situation where page
    //rotation is stuck because live tokens still exist in the
    //page we want to erase.  In this case we must do a repair to
    //get all live tokens into one virtual page. [BugzId:14392]
    //This bug pertains to SimEE2.
    //Fall into...
  }
  case EMBER_ERR_FLASH_WRITE_INHIBITED:
  case EMBER_ERR_FLASH_VERIFY_FAILED:
  { //Something went wrong while writing a token.  There is stale data and the
    //token the app expected to write did not get written.  Also there may
    //now be "stray" data written in the flash that could inhibit future token
    //writes.  To deal with stray/stale data, we must repair the Simulated
    //EEPROM.  Because the expected token write failed and will not be retried,
    //it is best to reset the chip and let normal boot sequences take over.
    //Since halInternalSimEeRepair() could potentially result in another write
    //failure, we use a simple semaphore to prevent recursion.
    static bool repairActive = false;
    if(!repairActive) {
      repairActive = true;
      halInternalSimEeRepair(false);
      switch (status) {
      case EMBER_SIM_EEPROM_ERASE_PAGE_RED:
      case EMBER_SIM_EEPROM_FULL:
        //Don't reboot - return to let SimEE code retry the token write
        //[BugzId:14392]
        break;
      case EMBER_ERR_FLASH_VERIFY_FAILED:
        //[[WBB350FIXME -It would be nice to have a unified, ]]
        //[[             platform independent reboot mechanism]]
        #if defined (CORTEXM3)
          halInternalSysReset(RESET_FLASH_VERIFY);
        #else
          assert(0);
        #endif
        break;
      case EMBER_ERR_FLASH_WRITE_INHIBITED:
        #if defined (CORTEXM3)
          halInternalSysReset(RESET_FLASH_INHIBIT);
        #else
          assert(0);
        #endif
        break;
      default:
        assert(0);
        break;
      }
      repairActive = false;
    }
    break;
  }
  case EMBER_SIM_EEPROM_REPAIRING:
    // While there's nothing for an app to do when the SimEE is going to
    // repair itself (SimEE has to be fully functional for the rest of the
    // system to work), alert the application to the fact that repairing
    // is occurring. There are debugging scenarios where an app might want
    // to know that repairing is happening; such as monitoring frequency.
    // NOTE:  Common situations will trigger an expected repair, such as
    //        using an erased chip or changing token definitions.
    break;
  default:
    // this condition indicates an unexpected problem.
    assert(0);
    break;
  }
}



void emberOrphanNotificationHandler(EmberEUI64 longId)
{
  return;
}



EmberStatus emberPanIdConflictHandler(int8_t conflictCount)
{
  return EMBER_SUCCESS;
}



/**@brief Invoked by the EmberZNet stack to filter out incoming
 * application MAC passthrough messages. If this returns true for a message
 * the complete message will be passed to emberMacPassthroughMessageHandler()
 * with a type of EMBER_MAC_PASSTHROUGH_APPLICATION.
 *
 * Note that this callback may be invoked in ISR context and should execute as
 * quickly as possible.
 *
 * Note that this callback may be called more than once per incoming message.
 * Therefore, the callback code should not depend on being called only once,
 * and should return the same value each time it is called with a given header.
 *
 * If the application includes this callback, it must define
 * EMBER_APPLICATION_HAS_MAC_PASSTHROUGH_FILTER_HANDLER in its
 * CONFIGURATION_HEADER.
 *
 * @param macHeader        A pointer to the initial portion of the
 *     incoming MAC header. This contains the MAC frame control and
 *     addressing fields. Subsequent MAC fields, and the MAC payload,
 *     may not be present.
 * @return true if the messages is an application MAC passthrough message.
 */
bool emberMacPassthroughFilterHandler(uint8_t *macHeader)
{
  return false;
}


/** @brief Intercepts an incoming packet from the stack and hands off to a plugin
 * for further processing
 *
 * @param packetType  The type of packet and the target stack layer.  See
 * ::EmberZigbeePacketType.
 * @param packetBuffer  The ::EmberMessageBuffer containing the packet.
 * @parma index  The starting index of the relevant packet data.  The plugin\
 * will receive a flat copy of the packet starting from this index.
 * @param data  Auxiliary data pointer
 *
 * @return  See ::EmberPacketAction
 */
EmberPacketAction emberPacketHandoffIncoming(EmberZigbeePacketType packetType,
                                             EmberMessageBuffer packetBuffer,
                                             uint8_t index,
                                             void *data)
{
  return EMBER_ACCEPT_PACKET;
}


/** @brief Intercepts an outgoing packet from the stack and hands off to a plugin
 * for further processing
 *
 * @param packetType  The type of packet and the source stack layer.  See
 * ::EmberZigbeePacketType.
 * @param packetBuffer  The ::EmberMessageBuffer containing the packet.
 * @param index  The starting index of the relevant packet data.  The plugin\
 * will receive a flat copy of the packet starting from this index.
 * @param data  Auxiliary data pointer
 *
 * @return  See ::EmberPacketAction
 */
EmberPacketAction emberPacketHandoffOutgoing(EmberZigbeePacketType packetType,
                                             EmberMessageBuffer packetBuffer,
                                             uint8_t index,
                                             void *data)
{
  return EMBER_ACCEPT_PACKET;
}


/** @brief Allows the application to manage idling the MCU.
 *
 * @return   True if the application is managing idling the MCU, false otherwise.
 * If this function returns false, the stack will manage idling the MCU.
 */
bool emberRtosIdleHandler(uint32_t *idleTimeMs)
{
  return false;
}


/** @brief Requests the application to wake up the stack task.
 */
void emberRtosStackWakeupIsrHandler(void)
{
}


/** @brief The radio calibration callback function.
 *
 * The Voltage Controlled Oscillator (VCO) can drift with
 * temperature changes. During every call to ::emberTick(), the stack will
 * check to see if the VCO has drifted. If the VCO has drifted, the stack
 * will call ::emberRadioNeedsCalibratingHandler() to inform the application
 * that it should perform calibration of the current channel as soon as
 * possible. Calibration can take up to 150 ms. The default callback function
 * implementation provided here performs calibration immediately. The
 * application can define its own callback by defining
 * ::EMBER_APPLICATION_HAS_CUSTOM_RADIO_CALIBRATION_CALLBACK in its
 * CONFIGURATION_HEADER. It can then failsafe any critical processes or
 * peripherals before calling ::emberCalibrateCurrentChannel(). The
 * application must call ::emberCalibrateCurrentChannel() in
 * response to this callback to maintain expected radio performance.
 */
void emberRadioNeedsCalibratingHandler(void)
{
  // TODO: Failsafe any critical processes or peripherals.
  emberCalibrateCurrentChannel();
}


