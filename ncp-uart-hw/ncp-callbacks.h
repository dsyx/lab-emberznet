// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// Enclosing macro to prevent multiple inclusion
#ifndef __NCP_CALLBACKS__
#define __NCP_CALLBACKS__


#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include EMBER_AF_API_EMBER_TYPES
#include "app/util/ezsp/ezsp-enum.h"
#include "hal/hal.h"
#include "app/util/ezsp/ezsp-frame-utilities.h"
#include EMBER_AF_API_HAL
#include EMBER_AF_API_SIM_EEPROM
#include EMBER_AF_API_ZIGBEE_PRO
#include EMBER_AF_API_STACK


/** @brief Provides the main application entry point.
 *
 * This callback provides the main application entry point for an NCP
 * application.
 */
int main(MAIN_FUNCTION_PARAMETERS);

void emberAfCounterHandler(EmberCounterType type, EmberCounterInfo info);

/** @brief NCP Application hook callback for green power messages.
 *
 * This function is called by the application hook plugin to allow
 * user to take an action gpd message is received. The return code
 * true indicate the user handled the message and false allows the
 * stack to handle it.
 *
 * @param status                     Ver.: always
 * @param gpdLink                    Ver.: always
 * @param sequenceNumber             Ver.: always
 * @param *addr                      Ver.: always
 * @param gpdfSecurityLevel          Ver.: always
 * @param gpdfSecurityKeyType        Ver.: always
 * @param autoCommissioning          Ver.: always
 * @param rxAfterTx                  Ver.: always
 * @param gpdSecurityFrameCounter    Ver.: always
 * @param gpdCommandId               Ver.: always
 * @param mic                        Ver.: always
 * @param proxyTableIndex            Ver.: always
 * @param gpdCommandPayloadLength    Ver.: always
 * @param *gpdCommandPayload         Ver.: always
 */
bool emberAfNcpGpepIncomingMessageHandler(GP_PARAMS);

void emberDebugHandler(EmberMessageBuffer message);

/** @brief Called when emberTrustCenterJoinHandler is called from the stack.
 *
 * The NCP will perform initial processing based on the current
 * ::EZSP_TRUST_CENTER_POLICY value and will pass this callback to the
 * NCP application. Implementations of this callback should return the
 * ::EmberJoinDecision value that will dictate the behavior of the trust center
 * in response to the new device joining or rejoining to the network.
 *
 * See documentation on the stack emberTrustCenterJoinHandler callback
 * for more information.
 *
 * @param newNodeId The node ID of the device wishing to join.
 * @param newNodeEui64 The EUI64 of the device wishing to join.
 * @param status The ::EmberUpdateDevice status indicating whether the
 * device is joining/rejoining or leaving, and whether the join/rejoin is
 * secure (using network encryption) or a trust center rejoin.
 * @param parentOfNewNode The node ID of the parent of device wishing to join.
 * @param decisionId The ::EzspDecisionId that the NCP is currently using
 * as set by the HOST application.
 * @param joinDecision The current ::EmberJoinDecision that the NCP has chosen
 * based on the ::EzspDecisionId for the ::EZSP_TRUST_CENTER_POLICY as set by the
 * HOST application. Implementations of this callback may want to return a
 * different value based on their desired security.
 *
 * @return An ::EmberJoinDecision value that will dictate the behavior of the
 * trust center in response to the new device joining or rejoining to
 * the network.
 */
EmberJoinDecision emberAfPluginEzspSecurityTrustCenterJoinCallback(EmberNodeId newNodeId,
                                                                   const EmberEUI64 newNodeEui64,
                                                                   EmberDeviceUpdate status,
                                                                   EmberNodeId parentOfNewNode,
                                                                   EzspDecisionId decisionId,
                                                                   EmberJoinDecision joinDecision);

EmberStatus emberAfPluginEzspZigbeeProSetConcentratorCommandCallback(bool on,
                                                                     uint16_t concentratorType,
                                                                     uint16_t minTime,
                                                                     uint16_t maxTime,
                                                                     uint8_t routeErrorThreshold,
                                                                     uint8_t deliveryFailureThreshold,
                                                                     uint8_t maxHops);

/**
 * @brief Called whenever the radio is powered on.
 */
void halRadioPowerUpHandler(void);

/**
 * @brief Called whenever the radio is powered off.
 */
void halRadioPowerDownHandler(void);

/**
 * @brief Called whenever the microcontroller enters/exits a idle/sleep mode
 *
 * @param enter        True if entering idle/sleep, False if exiting
 * @param sleepMode    Idle/sleep mode
 */
void halSleepCallback(boolean enter, SleepModes sleepMode);

/** @brief Notifies the application of the status
 *  of the request for a Link Key. The application should define
 *  EMBER_APPLICATION_HAS_ZIGBEE_KEY_ESTABLISHMENT_HANDLER to implement
 *  its own handler.
 *
 * @param partner The IEEE address of the partner device or all zeros if
 *   the Key establishment failed.
 * @param status The status of the key establishment.
 */
void emberZigbeeKeyEstablishmentHandler(EmberEUI64 partner,
                                        EmberKeyStatus status);

/** @brief Performs any additional initialization required at system startup.
 *
 * This function is called when the application starts and can be used to
 * perform any additional initialization required at system startup.
 */
void emberAfMainInitCallback(void);

/** @brief Called in each iteration of the main application loop.
 *
 * This function is called in each iteration of the main application loop and
 * can be used to perform periodic functions. The frequency with which this
 * function is called depends on how quickly the main loop runs. If the
 * application blocks at any time during the main loop, this function will not
 * be called until execution resumes.
 */
void emberAfMainTickCallback(void);

void emberSetOrGetEzspTokenCommandHandler(bool isSet);

bool emberAfPluginEzspAddEndpointCommandCallback(EmberMessageBuffer buffer);

/** @brief The Simulated EEPROM callback function, implemented by the
 * application.
 *
 * @param status  An ::EmberStatus error code indicating one of the conditions
 * described below.
 *
 * This callback will report an EmberStatus of
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN whenever a token is set and a page needs
 * to be erased. If the main application loop does not periodically
 * call halSimEepromErasePage(), it is best to then erase a page in
 * response to ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_ERASE_PAGE_RED
 * when the pages <i>must</i> be erased to prevent data loss.
 * halSimEepromErasePage() needs to be called until it returns 0 to indicate
 * there are no more pages that need to be erased.  Ignoring
 * this indication and not erasing the pages will cause dropping the new data
 * trying to be written.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_FULL when
 * the new data cannot be written due to unerased pages.  <b>Not erasing
 * pages regularly, not erasing in response to
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN, or not erasing in response to
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_RED will cause
 * ::EMBER_SIM_EEPROM_FULL and the new data will be lost!.</b>  Any future
 * write attempts will be lost as well.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_REPAIRING
 * when the Simulated EEPROM needs to repair itself. While there's nothing
 * for an app to do when the SimEE is going to repair itself (SimEE has to
 * be fully functional for the rest of the system to work), alert the
 * application to the fact that repairing is occurring. There are debugging
 * scenarios where an app might want to know that repairing is happening;
 * such as monitoring frequency.
 * @note  Common situations will trigger an expected repair, such as using
 *        a new chip or changing token definitions.
 *
 * If the callback ever reports the status ::EMBER_ERR_FLASH_WRITE_INHIBITED or
 * ::EMBER_ERR_FLASH_VERIFY_FAILED, a catastrophic failure has occurred in
 * flash writing, meaning either the address being written is not empty or the
 * write itself has failed. If ::EMBER_ERR_FLASH_WRITE_INHIBITED is
 * encountered, the function ::halInternalSimEeRepair(false) should be called
 * and the chip should then be reset to allow proper initialization to recover.
 * If ::EMBER_ERR_FLASH_VERIFY_FAILED is encountered the Simulated EEPROM (and
 * tokens) on the specific chip with this error should not be trusted anymore.
 *
 */
void halSimEepromCallback(EmberStatus status);

void emberOrphanNotificationHandler(EmberEUI64 longId);

EmberStatus emberPanIdConflictHandler(int8_t conflictCount);

/**@brief Invoked by the EmberZNet stack to filter out incoming
 * application MAC passthrough messages. If this returns true for a message
 * the complete message will be passed to emberMacPassthroughMessageHandler()
 * with a type of EMBER_MAC_PASSTHROUGH_APPLICATION.
 *
 * Note that this callback may be invoked in ISR context and should execute as
 * quickly as possible.
 *
 * Note that this callback may be called more than once per incoming message.
 * Therefore, the callback code should not depend on being called only once,
 * and should return the same value each time it is called with a given header.
 *
 * If the application includes this callback, it must define
 * EMBER_APPLICATION_HAS_MAC_PASSTHROUGH_FILTER_HANDLER in its
 * CONFIGURATION_HEADER.
 *
 * @param macHeader        A pointer to the initial portion of the
 *     incoming MAC header. This contains the MAC frame control and
 *     addressing fields. Subsequent MAC fields, and the MAC payload,
 *     may not be present.
 * @return true if the messages is an application MAC passthrough message.
 */
bool emberMacPassthroughFilterHandler(uint8_t *macHeader);

/** @brief Intercepts an incoming packet from the stack and hands off to a plugin
 * for further processing
 *
 * @param packetType  The type of packet and the target stack layer.  See
 * ::EmberZigbeePacketType.
 * @param packetBuffer  The ::EmberMessageBuffer containing the packet.
 * @parma index  The starting index of the relevant packet data.  The plugin\
 * will receive a flat copy of the packet starting from this index.
 * @param data  Auxiliary data pointer
 *
 * @return  See ::EmberPacketAction
 */
EmberPacketAction emberPacketHandoffIncoming(EmberZigbeePacketType packetType,
                                             EmberMessageBuffer packetBuffer,
                                             uint8_t index,
                                             void *data);

/** @brief Intercepts an outgoing packet from the stack and hands off to a plugin
 * for further processing
 *
 * @param packetType  The type of packet and the source stack layer.  See
 * ::EmberZigbeePacketType.
 * @param packetBuffer  The ::EmberMessageBuffer containing the packet.
 * @param index  The starting index of the relevant packet data.  The plugin\
 * will receive a flat copy of the packet starting from this index.
 * @param data  Auxiliary data pointer
 *
 * @return  See ::EmberPacketAction
 */
EmberPacketAction emberPacketHandoffOutgoing(EmberZigbeePacketType packetType,
                                             EmberMessageBuffer packetBuffer,
                                             uint8_t index,
                                             void *data);

/** @brief Invoked to inform the application of the
 * occurrence of an event defined by ::EmberCounterType, for example,
 * transmissions and receptions at different layers of the stack.
 *
 * The application must define ::EMBER_APPLICATION_HAS_COUNTER_HANDLER
 * in its CONFIGURATION_HEADER to use this.
 * This function may be called in ISR context, so processing should
 * be kept to a minimum.
 *
 * @param type  The type of the event.
 * @param info could map to:
 * 1. data: For transmission events, the number of retries used.
 * For most other events, this parameter is unused and is set to zero.
 * 2. phyIndex: use for mac specific counters specifying if they belong to SubGhz or 2.4
 * 3. destinationNodeId: identifying which connection/destinationId a specific counter refers to
 * 4. Any combination of parameters above
 */
void emberCounterHandler(EmberCounterType type, EmberCounterInfo info);

/** @brief Allows the application to manage idling the MCU.
 *
 * @return   True if the application is managing idling the MCU, false otherwise.
 * If this function returns false, the stack will manage idling the MCU.
 */
bool emberRtosIdleHandler(uint32_t *idleTimeMs);

/** @brief Requests the application to wake up the stack task.
 */
void emberRtosStackWakeupIsrHandler(void);

/** @brief Invoked when the status of the stack changes.
 * If the
 * status parameter equals ::EMBER_NETWORK_UP, the
 * ::emberGetNetworkParameters()
 * function can be called to obtain the new network parameters. If any of the
 * parameters are being stored in nonvolatile memory by the application, the
 * stored values should be updated.
 *
 * The application is free to begin messaging once it receives the
 * ::EMBER_NETWORK_UP status. However, routes discovered immediately after
 * the stack comes up may be suboptimal. This is because the routes are based
 * on the neighbor table's information about two-way links with neighboring nodes,
 * which is obtained from periodic Zigbee Link Status messages. It can take
 * two or three link status exchange periods (of 16 seconds each) before the
 * neighbor table has a good estimate of link quality to neighboring nodes.
 * Therefore, the application may improve the quality of initially discovered
 * routes by waiting after startup to give the neighbor table time
 * to be populated.
 *
 * @param status  Stack status. One of the following:
 * - ::EMBER_NETWORK_UP
 * - ::EMBER_NETWORK_DOWN
 * - ::EMBER_JOIN_FAILED
 * - ::EMBER_MOVE_FAILED
 * - ::EMBER_CANNOT_JOIN_AS_ROUTER
 * - ::EMBER_NODE_ID_CHANGED
 * - ::EMBER_PAN_ID_CHANGED
 * - ::EMBER_CHANNEL_CHANGED
 * - ::EMBER_NO_BEACONS
 * - ::EMBER_RECEIVED_KEY_IN_THE_CLEAR
 * - ::EMBER_NO_NETWORK_KEY_RECEIVED
 * - ::EMBER_NO_LINK_KEY_RECEIVED
 * - ::EMBER_PRECONFIGURED_KEY_REQUIRED
 */
void emberStackStatusHandler(EmberStatus status);

/** @brief Reports the maximum RSSI value measured on the channel.
 *
 * @param channel       The 802.15.4 channel number on which the RSSI value
 *   was measured.
 *
 * @param maxRssiValue  The maximum RSSI value measured (in units of dBm).
 *
 */
void emberEnergyScanResultHandler(uint8_t channel, int8_t maxRssiValue);

/** @brief The radio calibration callback function.
 *
 * The Voltage Controlled Oscillator (VCO) can drift with
 * temperature changes. During every call to ::emberTick(), the stack will
 * check to see if the VCO has drifted. If the VCO has drifted, the stack
 * will call ::emberRadioNeedsCalibratingHandler() to inform the application
 * that it should perform calibration of the current channel as soon as
 * possible. Calibration can take up to 150 ms. The default callback function
 * implementation provided here performs calibration immediately. The
 * application can define its own callback by defining
 * ::EMBER_APPLICATION_HAS_CUSTOM_RADIO_CALIBRATION_CALLBACK in its
 * CONFIGURATION_HEADER. It can then failsafe any critical processes or
 * peripherals before calling ::emberCalibrateCurrentChannel(). The
 * application must call ::emberCalibrateCurrentChannel() in
 * response to this callback to maintain expected radio performance.
 */
void emberRadioNeedsCalibratingHandler(void);

/** EZSP Command findAndRejoinNetwork(EZSP_FIND_AND_REJOIN_NETWORK)
 *
 * The application may call this function when contact with the network has been
 * lost. The most common usage case is when an end device can no longer
 * communicate with its parent and wishes to find a new one. Another case is
 * when a device has missed a Network Key update and no longer has the current
 * Network Key. <p> The stack will call <i>ezspStackStatusHandler</i> to
 * indicate that the network is down, then try to re-establish contact with the
 * network by performing an active scan, choosing a network with matching
 * extended pan id, and sending a ZigBee network rejoin request. A second call
 * to the <i>ezspStackStatusHandler</i> callback indicates either the success or
 * the failure of the attempt. The process takes approximately 150 milliseconds
 * per channel to complete. <p>
 *
 * @param haveCurrentNetworkKey
 * This parameter tells the stack whether to try to use the current network
 * key. If it has the current network key it will perform a secure rejoin
 * (encrypted). If this fails the device should try an unsecure rejoin. If the
 * Trust Center allows the rejoin then the current Network Key will be sent
 * encrypted using the device's Link Key.
 * @param channelMask
 * A mask indicating the channels to be scanned. See <i>emberStartScan</i> for
 * format details. A value of 0 is reinterpreted as the mask for the current
 * channel.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspFindAndRejoinNetworkCommandCallback(bool haveCurrentNetworkKey,
                                                           uint32_t channelMask);

/** EZSP Command getChildData(EZSP_GET_CHILD_DATA)
 *
 * Returns information about a child of the local node.
 *
 * @param index
 * The index of the child of interest in the child table. Possible indexes
 * range from zero to EMBER_CHILD_TABLE_SIZE.
 * @param childData
 * The data of the child.
 *
 * @return
 * EMBER_SUCCESS if there is a child at <i>index</i>. EMBER_NOT_JOINED if there
 * is no child at <i>index</i>.
 */
EmberStatus emberAfEzspGetChildDataCommandCallback(uint8_t index,
                                                   EmberChildData* childData);

/** EZSP Command getCurrentDutyCycle(EZSP_GET_CURRENT_DUTY_CYCLE)
 *
 * Returns the duty cycle of the stack's connected children that are being
 * monitored, up to maxDevices. It indicates the amount of overall duty cycle
 * they have consumed (up to the suspend limit). The first entry is always the
 * local stack's nodeId, and thus the total aggregate duty cycle for the device.
 * The passed pointer arrayOfDeviceDutyCycles MUST have space for maxDevices.
 *
 * @param maxDevices
 * Number of devices to retrieve consumed duty cycle.
 * @param arrayOfDeviceDutyCycles
 * Consumed duty cycles up to maxDevices. When the number of children that are
 * being monitored is less than maxDevices, the EmberNodeId element in the
 * EmberPerDeviceDutyCycle will be 0xFFFF.
 *
 * @return
 * EMBER_SUCCESS  if the duty cycles were read successfully, EMBER_BAD_ARGUMENT
 * maxDevices is greater than EMBER_MAX_END_DEVICE_CHILDREN + 1.
 */
EmberStatus emberAfEzspGetCurrentDutyCycleCommandCallback(uint8_t maxDevices,
                                                          uint8_t arrayOfDeviceDutyCycles[]);

/** EZSP Command getNetworkParameters(EZSP_GET_NETWORK_PARAMETERS)
 *
 * Returns the current network parameters.
 *
 * @param nodeType
 * An EmberNodeType value indicating the current node type.
 * @param parameters
 * The current network parameters.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspGetNetworkParametersCommandCallback(EmberNodeType* nodeType,
                                                           EmberNetworkParameters* parameters);

/** EZSP Command getParentChildParameters(EZSP_GET_PARENT_CHILD_PARAMETERS)
 *
 * Returns information about the children of the local node and the parent of
 * the local node.
 *
 * @param parentEui64
 * The parent's EUI64. The value is undefined for nodes without parents
 * (coordinators and nodes that are not joined to a network).
 * @param parentNodeId
 * The parent's node ID. The value is undefined for nodes without parents
 * (coordinators and nodes that are not joined to a network).
 *
 * @return
 * The number of children the node currently has.
 */
uint8_t emberAfEzspGetParentChildParametersCommandCallback(EmberEUI64 parentEui64,
                                                           EmberNodeId* parentNodeId);

/** EZSP Command getRoutingShortcutThreshold(EZSP_GET_ROUTING_SHORTCUT_THRESHOLD)
 *
 * Gets the routing shortcut threshold used to differentiate between directly
 * using a neighbor vs. performing routing.
 *
 *
 * @return
 * The routing shortcut threshold
 */
uint8_t emberAfEzspGetRoutingShortcutThresholdCommandCallback(void);

/** EZSP Command getSourceRouteTableEntry(EZSP_GET_SOURCE_ROUTE_TABLE_ENTRY)
 *
 * Returns information about a source route table entry
 *
 * @param index
 * The index of the entry of interest in the
source route table. Possible
 * indexes range from zero to
SOURCE_ROUTE_TABLE_FILLED_SIZE.
 * @param destination
 * The node ID of the destination in that entry.
 * @param closerIndex
 * The closer node index for this source route table entry
 *
 * @return
 * EMBER_SUCCESS if there is source route entry at
<i>index</i>.
 * EMBER_SOURCE_ROUTE_FAILURE if there is no
source route at <i>index</i>.
 */
EmberStatus emberAfEzspGetSourceRouteTableEntryCommandCallback(uint8_t index,
                                                               EmberNodeId* destination,
                                                               uint8_t* closerIndex);

/** EZSP Command getSourceRouteTableFilledSize(EZSP_GET_SOURCE_ROUTE_TABLE_FILLED_SIZE)
 *
 * Returns the number of filled entries in source route table.
 *
 *
 * @return
 * The number of filled entries in source route table.
 */
uint8_t emberAfEzspGetSourceRouteTableFilledSizeCommandCallback(void);

/** EZSP Command getSourceRouteTableTotalSize(EZSP_GET_SOURCE_ROUTE_TABLE_TOTAL_SIZE)
 *
 * Returns the source route table total size.
 *
 *
 * @return
 * Total size of source route table.
 */
uint8_t emberAfEzspGetSourceRouteTableTotalSizeCommandCallback(void);

/** EZSP Command setBrokenRouteErrorCode(EZSP_SET_BROKEN_ROUTE_ERROR_CODE)
 *
 * Sets the error code that is sent back from a router with a broken route.
 *
 * @param errorCode
 * Desired error code.
 *
 * @return
 * An EmberStatus value indicating the success or failure of the command.
 */
EmberStatus emberAfEzspSetBrokenRouteErrorCodeCommandCallback(uint8_t errorCode);

/** EZSP Command setRoutingShortcutThreshold(EZSP_SET_ROUTING_SHORTCUT_THRESHOLD)
 *
 * Sets the routing shortcut threshold to directly use a neighbor instead of
 * performing routing.
 *
 * @param costThresh
 * The routing shortcut threshold to configure.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspSetRoutingShortcutThresholdCommandCallback(uint8_t costThresh);

/** EZSP Command getMulticastTableEntry(EZSP_GET_MULTICAST_TABLE_ENTRY)
 *
 * Gets an entry from the multicast table.
 *
 * @param index
 * The index of a multicast table entry.
 * @param value
 * The contents of the multicast entry.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspGetMulticastTableEntryCommandCallback(uint8_t index,
                                                             EmberMulticastTableEntry* value);

/** EZSP Command pollForData(EZSP_POLL_FOR_DATA)
 *
 * Periodically request any pending data from our parent. Setting
 * <i>interval</i> to 0 or <i>units</i> to EMBER_EVENT_INACTIVE will generate a
 * single poll.
 *
 * @param interval
 * The time between polls. Note that the timer clock is free running and is not
 * synchronized with this command. This means that the time will be between
 * <i>interval</i> and (<i>interval</i> - 1). The maximum interval is 32767.
 * @param units
 * The units for <i>interval</i>.
 * @param failureLimit
 * The number of poll failures that will be tolerated before a
 * <i>pollCompleteHandler</i> callback is generated. A value of zero will
 * result in a callback for every poll. Any status value apart from
 * EMBER_SUCCESS and EMBER_MAC_NO_DATA is counted as a failure.
 *
 * @return
 * The result of sending the first poll.
 */
EmberStatus emberAfEzspPollForDataCommandCallback(uint16_t interval,
                                                  EmberEventUnits units,
                                                  uint8_t failureLimit);

/** EZSP Command proxyBroadcast(EZSP_PROXY_BROADCAST)
 *
 * Sends a proxied broadcast message as per the ZigBee specification.
 *
 * @param source
 * The source from which to send the broadcast.
 * @param destination
 * The destination to which to send the broadcast. This must be one of the
 * three ZigBee broadcast addresses.
 * @param nwkSequence
 * The network sequence number for the broadcast.
 * @param apsFrame
 * The APS frame for the message.
 * @param radius
 * The message will be delivered to all nodes within <i>radius</i> hops of the
 * sender. A radius of zero is converted to EMBER_MAX_HOPS.
 * @param messageTag
 * A value chosen by the Host. This value is used in the
 * <i>ezspMessageSentHandler</i> response to refer to this message.
 * @param messageLength
 * The length of the <i>messageContents</i> parameter in bytes.
 * @param messageContents
 * The broadcast message.
 * @param apsSequence
 * The APS sequence number that will be used when this message is transmitted.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspProxyBroadcastCommandCallback(EmberNodeId source,
                                                     EmberNodeId destination,
                                                     uint8_t nwkSequence,
                                                     EmberApsFrame* apsFrame,
                                                     uint8_t radius,
                                                     uint8_t messageTag,
                                                     uint8_t messageLength,
                                                     uint8_t messageContents[],
                                                     uint8_t* apsSequence);

/** EZSP Command replaceAddressTableEntry(EZSP_REPLACE_ADDRESS_TABLE_ENTRY)
 *
 * Replaces the EUI64, short ID and extended timeout setting of an address table
 * entry. The previous EUI64, short ID and extended timeout setting are
 * returned.
 *
 * @param addressTableIndex
 * The index of the address table entry that will be modified.
 * @param newEui64
 * The EUI64 to be written to the address table entry.
 * @param newId
 * One of the following: The short ID corresponding to the new EUI64.
 * EMBER_UNKNOWN_NODE_ID if the new EUI64 is valid but the short ID is unknown
 * and should be discovered by the stack. EMBER_TABLE_ENTRY_UNUSED_NODE_ID if
 * the address table entry is now unused.
 * @param newExtendedTimeout
 * true if the retry interval should be increased by
 * EMBER_INDIRECT_TRANSMISSION_TIMEOUT. false if the normal retry interval
 * should be used.
 * @param oldEui64
 * The EUI64 of the address table entry before it was modified.
 * @param oldId
 * One of the following: The short ID corresponding to the EUI64 before it was
 * modified. EMBER_UNKNOWN_NODE_ID if the short ID was unknown.
 * EMBER_DISCOVERY_ACTIVE_NODE_ID if discovery of the short ID was underway.
 * EMBER_TABLE_ENTRY_UNUSED_NODE_ID if the address table entry was unused.
 * @param oldExtendedTimeout
 * true if the retry interval was being increased by
 * EMBER_INDIRECT_TRANSMISSION_TIMEOUT. false if the normal retry interval was
 * being used.
 *
 * @return
 * EMBER_SUCCESS if the EUI64, short ID and extended timeout setting were
 * successfully modified, and EMBER_ADDRESS_TABLE_ENTRY_IS_ACTIVE otherwise.
 */
EmberStatus emberAfEzspReplaceAddressTableEntryCommandCallback(uint8_t addressTableIndex,
                                                               EmberEUI64 newEui64,
                                                               EmberNodeId newId,
                                                               bool newExtendedTimeout,
                                                               EmberEUI64 oldEui64,
                                                               EmberNodeId* oldId,
                                                               bool* oldExtendedTimeout);

/** EZSP Command sendBroadcast(EZSP_SEND_BROADCAST)
 *
 * Sends a broadcast message as per the ZigBee specification.
 *
 * @param destination
 * The destination to which to send the broadcast. This must be one of the
 * three ZigBee broadcast addresses.
 * @param apsFrame
 * The APS frame for the message.
 * @param radius
 * The message will be delivered to all nodes within <i>radius</i> hops of the
 * sender. A radius of zero is converted to EMBER_MAX_HOPS.
 * @param messageTag
 * A value chosen by the Host. This value is used in the
 * <i>ezspMessageSentHandler</i> response to refer to this message.
 * @param messageLength
 * The length of the <i>messageContents</i> parameter in bytes.
 * @param messageContents
 * The broadcast message.
 * @param sequence
 * The sequence number that will be used when this message is transmitted.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspSendBroadcastCommandCallback(EmberNodeId destination,
                                                    EmberApsFrame* apsFrame,
                                                    uint8_t radius,
                                                    uint8_t messageTag,
                                                    uint8_t messageLength,
                                                    uint8_t messageContents[],
                                                    uint8_t* sequence);

/** EZSP Command sendMulticast(EZSP_SEND_MULTICAST)
 *
 * Sends a multicast message to all endpoints that share a specific multicast ID
 * and are within a specified number of hops of the sender.
 *
 * @param apsFrame
 * The APS frame for the message. The multicast will be sent to the groupId in
 * this frame.
 * @param hops
 * The message will be delivered to all nodes within this number of hops of the
 * sender. A value of zero is converted to EMBER_MAX_HOPS.
 * @param nonmemberRadius
 * The number of hops that the message will be forwarded by devices that are
 * not members of the group. A value of 7 or greater is treated as infinite.
 * @param messageTag
 * A value chosen by the Host. This value is used in the
 * <i>ezspMessageSentHandler</i> response to refer to this message.
 * @param messageLength
 * The length of the <i>messageContents</i> parameter in bytes.
 * @param messageContents
 * The multicast message.
 * @param sequence
 * The sequence number that will be used when this message is transmitted.
 *
 * @return
 * An EmberStatus value. For any result other than EMBER_SUCCESS, the message
 * will not be sent. EMBER_SUCCESS - The message has been submitted for
 * transmission. EMBER_INVALID_BINDING_INDEX - The bindingTableIndex refers to
 * a non-multicast binding. EMBER_NETWORK_DOWN - The node is not part of a
 * network. EMBER_MESSAGE_TOO_LONG - The message is too large to fit in a MAC
 * layer frame. EMBER_NO_BUFFERS - The free packet buffer pool is empty.
 * EMBER_NETWORK_BUSY - Insufficient resources available in Network or MAC
 * layers to send message.
 */
EmberStatus emberAfEzspSendMulticastCommandCallback(EmberApsFrame* apsFrame,
                                                    uint8_t hops,
                                                    uint8_t nonmemberRadius,
                                                    uint8_t messageTag,
                                                    uint8_t messageLength,
                                                    uint8_t messageContents[],
                                                    uint8_t* sequence);

/** EZSP Command sendMulticastWithAlias(EZSP_SEND_MULTICAST_WITH_ALIAS)
 *
 * Sends a multicast message to all endpoints that share a specific multicast ID
 * and are within a specified number of hops of the sender.
 *
 * @param apsFrame
 * The APS frame for the message. The multicast will be sent to the groupId in
 * this frame.
 * @param hops
 * The message will be delivered to all nodes within this number of hops of the
 * sender. A value of zero is converted to EMBER_MAX_HOPS.
 * @param nonmemberRadius
 * The number of hops that the message will be forwarded by devices that are
 * not members of the group. A value of 7 or greater is treated as infinite.
 * @param alias
 * The alias source address
 * @param nwkSequence
 * the alias sequence number
 * @param messageTag
 * A value chosen by the Host. This value is used in the
 * <i>ezspMessageSentHandler</i> response to refer to this message.
 * @param messageLength
 * The length of the <i>messageContents</i> parameter in bytes.
 * @param messageContents
 * The multicast message.
 * @param sequence
 * The sequence number that will be used when this message is transmitted.
 *
 * @return
 * An EmberStatus value. For any result other than EMBER_SUCCESS, the message
 * will not be sent. EMBER_SUCCESS - The message has been submitted for
 * transmission. EMBER_INVALID_BINDING_INDEX - The bindingTableIndex refers to
 * a non-multicast binding. EMBER_NETWORK_DOWN - The node is not part of a
 * network. EMBER_MESSAGE_TOO_LONG - The message is too large to fit in a MAC
 * layer frame. EMBER_NO_BUFFERS - The free packet buffer pool is empty.
 * EMBER_NETWORK_BUSY - Insufficient resources available in Network or MAC
 * layers to send message.
 */
EmberStatus emberAfEzspSendMulticastWithAliasCommandCallback(EmberApsFrame* apsFrame,
                                                             uint8_t hops,
                                                             uint8_t nonmemberRadius,
                                                             uint16_t alias,
                                                             uint8_t nwkSequence,
                                                             uint8_t messageTag,
                                                             uint8_t messageLength,
                                                             uint8_t messageContents[],
                                                             uint8_t* sequence);

/** EZSP Command sendRawMessage(EZSP_SEND_RAW_MESSAGE)
 *
 * Transmits the given message without modification. The MAC header is assumed
 * to be configured in the message at the time this function is called.
 *
 * @param messageLength
 * The length of the <i>messageContents</i> parameter in bytes.
 * @param messageContents
 * The raw message.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspSendRawMessageCommandCallback(uint8_t messageLength,
                                                     uint8_t messageContents[]);

/** EZSP Command sendReply(EZSP_SEND_REPLY)
 *
 * Sends a reply to a received unicast message. The
 * <i>incomingMessageHandler</i> callback for the unicast being replied to
 * supplies the values for all the parameters except the reply itself.
 *
 * @param sender
 * Value supplied by incoming unicast.
 * @param apsFrame
 * Value supplied by incoming unicast.
 * @param messageLength
 * The length of the <i>messageContents</i> parameter in bytes.
 * @param messageContents
 * The reply message.
 *
 * @return
 * An EmberStatus value. EMBER_INVALID_CALL - The EZSP_UNICAST_REPLIES_POLICY
 * is set to EZSP_HOST_WILL_NOT_SUPPLY_REPLY. This means the NCP will
 * automatically send an empty reply. The Host must change the policy to
 * EZSP_HOST_WILL_SUPPLY_REPLY before it can supply the reply. There is one
 * exception to this rule: In the case of responses to message fragments, the
 * host must call sendReply when a message fragment is received. In this case,
 * the policy set on the NCP does not matter. The NCP expects a sendReply call
 * from the Host for message fragments regardless of the current policy
 * settings. EMBER_NO_BUFFERS - Not enough memory was available to send the
 * reply. EMBER_NETWORK_BUSY - Either no route or insufficient resources
 * available. EMBER_SUCCESS - The reply was successfully queued for
 * transmission.
 */
EmberStatus emberAfEzspSendReplyCommandCallback(EmberNodeId sender,
                                                EmberApsFrame* apsFrame,
                                                uint8_t messageLength,
                                                uint8_t messageContents[]);

/** EZSP Command sendUnicast(EZSP_SEND_UNICAST)
 *
 * Sends a unicast message as per the ZigBee specification. The message will
 * arrive at its destination only if there is a known route to the destination
 * node. Setting the ENABLE_ROUTE_DISCOVERY option will cause a route to be
 * discovered if none is known. Setting the FORCE_ROUTE_DISCOVERY option will
 * force route discovery. Routes to end-device children of the local node are
 * always known. Setting the APS_RETRY option will cause the message to be
 * retransmitted until either a matching acknowledgement is received or three
 * transmissions have been made. <b>Note:</b> Using the FORCE_ROUTE_DISCOVERY
 * option will cause the first transmission to be consumed by a route request as
 * part of discovery, so the application payload of this packet will not reach
 * its destination on the first attempt. If you want the packet to reach its
 * destination, the APS_RETRY option must be set so that another attempt is made
 * to transmit the message with its application payload after the route has been
 * constructed. <b>Note:</b> When sending fragmented messages, the stack will
 * only assign a new APS sequence number for the first fragment of the message
 * (i.e., EMBER_APS_OPTION_FRAGMENT is set and the low-order byte of the groupId
 * field in the APS frame is zero). For all subsequent fragments of the same
 * message, the application must set the sequence number field in the APS frame
 * to the sequence number assigned by the stack to the first fragment.
 *
 * @param type
 * Specifies the outgoing message type. Must be one of EMBER_OUTGOING_DIRECT,
 * EMBER_OUTGOING_VIA_ADDRESS_TABLE, or EMBER_OUTGOING_VIA_BINDING.
 * @param indexOrDestination
 * Depending on the type of addressing used, this is either the EmberNodeId of
 * the destination, an index into the address table, or an index into the
 * binding table.
 * @param apsFrame
 * The APS frame which is to be added to the message.
 * @param messageTag
 * A value chosen by the Host. This value is used in the
 * <i>ezspMessageSentHandler</i> response to refer to this message.
 * @param messageLength
 * The length of the <i>messageContents</i> parameter in bytes.
 * @param messageContents
 * Content of the message.
 * @param sequence
 * The sequence number that will be used when this message is transmitted.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspSendUnicastCommandCallback(EmberOutgoingMessageType type,
                                                  EmberNodeId indexOrDestination,
                                                  EmberApsFrame* apsFrame,
                                                  uint8_t messageTag,
                                                  uint8_t messageLength,
                                                  uint8_t messageContents[],
                                                  uint8_t* sequence);

/** EZSP Command setMulticastTableEntry(EZSP_SET_MULTICAST_TABLE_ENTRY)
 *
 * Sets an entry in the multicast table.
 *
 * @param index
 * The index of a multicast table entry
 * @param value
 * The contents of the multicast entry.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspSetMulticastTableEntryCommandCallback(uint8_t index,
                                                             EmberMulticastTableEntry* value);

/** EZSP Command setSourceRoute(EZSP_SET_SOURCE_ROUTE)
 *
 * Supply a source route for the next outgoing message.
 *
 * @param destination
 * The destination of the source route.
 * @param relayCount
 * The number of relays in <i>relayList</i>.
 * @param relayList
 * The source route.
 *
 * @return
 * EMBER_SUCCESS if the source route was successfully stored, and
 * EMBER_NO_BUFFERS otherwise.
 */
EmberStatus emberAfEzspSetSourceRouteCommandCallback(EmberNodeId destination,
                                                     uint8_t relayCount,
                                                     uint16_t relayList[]);

/** EZSP Command unicastCurrentNetworkKey(EZSP_UNICAST_CURRENT_NETWORK_KEY)
 *
 * Send the network key to a destination.
 *
 * @param targetShort
 * The destination node of the key.
 * @param targetLong
 * The long address of the destination node.
 * @param parentShortId
 * The parent node of the destination node.
 *
 * @return
 * EMBER_SUCCESS if send was successful
 */
EmberStatus emberAfEzspUnicastCurrentNetworkKeyCommandCallback(EmberNodeId targetShort,
                                                               EmberEUI64 targetLong,
                                                               EmberNodeId parentShortId);

/** EZSP Command getLogicalChannel(EZSP_GET_LOGICAL_CHANNEL)
 *
 * Get the logical channel from the ZLL stack.
 *
 *
 * @return
 * The logical channel.
 */
uint8_t emberAfEzspGetLogicalChannelCommandCallback(void);

/** EZSP Command setLogicalAndRadioChannel(EZSP_SET_LOGICAL_AND_RADIO_CHANNEL)
 *
 * This call sets the radio channel in the stack and propagates the information
 * to the hardware.
 *
 * @param radioChannel
 * The radio channel to be set.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspSetLogicalAndRadioChannelCommandCallback(uint8_t radioChannel);

/** EZSP Command zllNetworkOps(EZSP_ZLL_NETWORK_OPS)
 *
 * A consolidation of ZLL network operations with similar signatures;
 * specifically, forming and joining networks or touch-linking.
 *
 * @param networkInfo
 * Information about the network.
 * @param op
 * Operation indicator.
 * @param radioTxPower
 * Radio transmission power.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspZllNetworkOpsCommandCallback(EmberZllNetwork* networkInfo,
                                                    EzspZllNetworkOperation op,
                                                    int8_t radioTxPower);

/** EZSP Command addTransientLinkKey(EZSP_ADD_TRANSIENT_LINK_KEY)
 *
 * This is a function to add a temporary link key for a joining device. The key
 * will get timed out after a defined timeout period if the device does not
 * update its link key with the Trust Center.
 *
 * @param partner
 * This is the IEEE address of the partner that the device successfully
 * established a key with. This value is all zeros on a failure.
 * @param transientKey
 * The transient key data for the joining device.
 *
 * @return
 * The success or failure of adding a transient key.
 */
EmberStatus emberAfEzspAddTransientLinkKeyCommandCallback(EmberEUI64 partner,
                                                          EmberKeyData* transientKey);

/** EZSP Command getTransientLinkKey(EZSP_GET_TRANSIENT_LINK_KEY)
 *
 * This is a function to get the transient link key structure in the transient
 * key table. The EUI of the passed in key structure is searched and, if a match
 * is found, the rest of the key structure is filled in.
 *
 * @param eui
 * The IEEE address to look up the transient key for.
 * @param transientKeyData
 * The transient key structure that is filled in upon success.
 *
 * @return
 * The success or failure of getting the transient key.
 */
EmberStatus emberAfEzspGetTransientLinkKeyCommandCallback(EmberEUI64 eui,
                                                          EmberTransientKeyData* transientKeyData);

/** EZSP Command aesMmoHash(EZSP_AES_MMO_HASH)
 *
 * This routine processes the passed chunk of data and updates the hash context
 * based on it. If the 'finalize' parameter is not set, then the length of the
 * data passed in must be a multiple of 16. If the 'finalize' parameter is set
 * then the length can be any value up 1-16, and the final hash value will be
 * calculated.
 *
 * @param context
 * The hash context to update.
 * @param finalize
 * This indicates whether the final hash value should be calculated
 * @param length
 * The length of the data to hash.
 * @param data
 * The data to hash.
 * @param returnContext
 * The updated hash context.
 *
 * @return
 * The result of the operation
 */
EmberStatus emberAfEzspAesMmoHashCommandCallback(EmberAesMmoHashContext* context,
                                                 bool finalize,
                                                 uint8_t length,
                                                 uint8_t data[],
                                                 EmberAesMmoHashContext* returnContext);

/** EZSP Command deleteBinding(EZSP_DELETE_BINDING)
 *
 * Deletes a binding table entry.
 *
 * @param index
 * The index of a binding table entry.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspDeleteBindingCommandCallback(uint8_t index);

/** EZSP Command setBinding(EZSP_SET_BINDING)
 *
 * Sets an entry in the binding table.
 *
 * @param index
 * The index of a binding table entry.
 * @param value
 * The contents of the binding entry.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspSetBindingCommandCallback(uint8_t index,
                                                 EmberBindingTableEntry* value);

/** EZSP Command mfglibSendPacket(EZSP_MFGLIB_SEND_PACKET)
 *
 * Sends a single packet consisting of the following bytes: packetLength,
 * packetContents[0], ... , packetContents[packetLength - 3], CRC[0], CRC[1].
 * The total number of bytes sent is packetLength + 1. The radio replaces the
 * last two bytes of packetContents[] with the 16-bit CRC for the packet.
 *
 * @param packetLength
 * The length of the packetContents parameter in bytes. Must be greater than 3
 * and less than 123.
 * @param packetContents
 * The packet to send. The last two bytes will be replaced with the 16-bit CRC.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspMfglibSendPacketCommandCallback(uint8_t packetLength,
                                                       uint8_t packetContents[]);

/** EZSP Command mfglibStart(EZSP_MFGLIB_START)
 *
 * Activate use of mfglib test routines and enables the radio receiver to report
 * packets it receives to the mfgLibRxHandler() callback. These packets will not
 * be passed up with a CRC failure. All other mfglib functions will return an
 * error until the mfglibStart() has been called
 *
 * @param rxCallback
 * true to generate a mfglibRxHandler callback when a packet is received.
 *
 * @return
 * An EmberStatus value indicating success or the reason for failure.
 */
EmberStatus emberAfEzspMfglibStartCommandCallback(bool rxCallback);

/** EZSP Command dsaSign(EZSP_DSA_SIGN)
 *
 * LEGACY FUNCTION: This functionality has been replaced by a single bit in the
 * EmberApsFrame, EMBER_APS_OPTION_DSA_SIGN. Devices wishing to send signed
 * messages should use that as it requires fewer function calls and message
 * buffering. The dsaSignHandler response is still called when
 * EMBER_APS_OPTION_DSA_SIGN is used. However, this function is still supported.
 * This function begins the process of signing the passed message contained
 * within the messageContents array. If no other ECC operation is going on, it
 * will immediately return with EMBER_OPERATION_IN_PROGRESS to indicate the
 * start of ECC operation. It will delay a period of time to let APS retries
 * take place, but then it will shut down the radio and consume the CPU
 * processing until the signing is complete. This may take up to 1 second. The
 * signed message will be returned in the dsaSignHandler response. Note that the
 * last byte of the messageContents passed to this function has special
 * significance. As the typical use case for DSA signing is to sign the ZCL
 * payload of a DRLC Report Event Status message in SE 1.0, there is often both
 * a signed portion (ZCL payload) and an unsigned portion (ZCL header). The last
 * byte in the content of messageToSign is therefore used as a special indicator
 * to signify how many bytes of leading data in the array should be excluded
 * from consideration during the signing process. If the signature needs to
 * cover the entire array (all bytes except last one), the caller should ensure
 * that the last byte of messageContents is 0x00. When the signature operation
 * is complete, this final byte will be replaced by the signature type indicator
 * (0x01 for ECDSA signatures), and the actual signature will be appended to the
 * original contents after this byte.
 *
 * @param messageLength
 * The length of the <i>messageContents</i> parameter in bytes.
 * @param messageContents
 * The message contents for which to create a signature. Per above notes, this
 * may include a leading portion of data not included in the signature, in
 * which case the last byte of this array should be set to the index of the
 * first byte to be considered for signing. Otherwise, the last byte of
 * messageContents should be 0x00 to indicate that a signature should occur
 * across the entire contents.
 *
 * @return
 * EMBER_OPERATION_IN_PROGRESS if the stack has queued up the operation for
 * execution. EMBER_INVALID_CALL if the operation can't be performed in this
 * context, possibly because another ECC operation is pending.
 */
EmberStatus emberAfEzspDsaSignCommandCallback(uint8_t messageLength,
                                              uint8_t messageContents[]);

/** EZSP Command savePreinstalledCbkeData283k1(EZSP_SAVE_PREINSTALLED_CBKE_DATA283K1)
 *
 * Sets the device's 283k1 curve CA public key, local certificate, and static
 * private key on the NCP associated with this node.
 *
 *
 * @return
 * 
 */
EmberStatus emberAfEzspSavePreinstalledCbkeData283k1CommandCallback(void);

#endif // __NCP_CALLBACKS__
