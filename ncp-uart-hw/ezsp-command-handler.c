// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include EMBER_AF_API_EMBER_TYPES
#include EMBER_AF_API_EZSP
#include EMBER_AF_API_MFGLIB
#include EMBER_AF_API_CBKE
#include "ncp-callbacks.h"

bool emAfProcessEzspCommand(uint8_t commandId)
{
  switch(commandId) {
// -----------------------------------------------------------------------------
// Networking Frames

  case EZSP_CLEAR_STORED_BEACONS: {
    // Callback.
    emberClearStoredBeacons();
    break;
  }

  case EZSP_ENERGY_SCAN_REQUEST: {
    // Command arguments.
    EmberNodeId target;
    uint32_t scanChannels;
    uint8_t scanDuration;
    uint16_t scanCount;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vwuv",
                      &target,
                      &scanChannels,
                      &scanDuration,
                      &scanCount);
    // Callback.
    status = emberEnergyScanRequest(target,
                                    scanChannels,
                                    scanDuration,
                                    scanCount);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_FIND_AND_REJOIN_NETWORK: {
    // Command arguments.
    bool haveCurrentNetworkKey;
    uint32_t channelMask;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uw",
                      &haveCurrentNetworkKey,
                      &channelMask);
    // Callback.
    status = emberAfEzspFindAndRejoinNetworkCommandCallback(haveCurrentNetworkKey,
                                                            channelMask);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_FIND_UNUSED_PAN_ID: {
    // Command arguments.
    uint32_t channelMask;
    uint8_t duration;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "wu",
                      &channelMask,
                      &duration);
    // Callback.
    status = emberFindUnusedPanId(channelMask,
                                  duration);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_FORM_NETWORK: {
    // Command arguments.
    EmberNetworkParameters parameters;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberNetworkParameters(&parameters);
    // Callback.
    status = emberFormNetwork(&parameters);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_GET_CHILD_DATA: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    EmberChildData childData;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberAfEzspGetChildDataCommandCallback(index,
                                                    &childData);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberChildData(&childData);
    break;
  }

  case EZSP_GET_CURRENT_DUTY_CYCLE: {
    // Command arguments.
    uint8_t maxDevices;
    // Response arguments.
    EmberStatus status;
    uint8_t arrayOfDeviceDutyCyclesLength = 134;
    uint8_t arrayOfDeviceDutyCycles[134];
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &maxDevices);
    // Callback.
    status = emberAfEzspGetCurrentDutyCycleCommandCallback(maxDevices,
                                                           arrayOfDeviceDutyCycles);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "ub",
                      &status,
                      &arrayOfDeviceDutyCycles,
                      &arrayOfDeviceDutyCyclesLength);
    break;
  }

  case EZSP_GET_DUTY_CYCLE_LIMITS: {
    // Response arguments.
    EmberStatus status;
    EmberDutyCycleLimits returnedLimits;
    // Callback.
    status = emberGetDutyCycleLimits(&returnedLimits);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberDutyCycleLimits(&returnedLimits);
    break;
  }

  case EZSP_GET_DUTY_CYCLE_STATE: {
    // Response arguments.
    EmberStatus status;
    EmberDutyCycleState returnedState;
    // Callback.
    status = emberGetDutyCycleState(&returnedState);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "uu",
                      &status,
                      &returnedState);
    break;
  }

  case EZSP_GET_FIRST_BEACON: {
    // Response arguments.
    EmberStatus status;
    EmberBeaconIterator beaconIterator;
    // Callback.
    status = emberGetFirstBeacon(&beaconIterator);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberBeaconIterator(&beaconIterator);
    break;
  }

  case EZSP_GET_NEIGHBOR: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    EmberNeighborTableEntry value;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberGetNeighbor(index,
                              &value);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberNeighborTableEntry(&value);
    break;
  }

  case EZSP_GET_NETWORK_PARAMETERS: {
    // Response arguments.
    EmberStatus status;
    EmberNodeType nodeType;
    EmberNetworkParameters parameters;
    // Callback.
    status = emberAfEzspGetNetworkParametersCommandCallback(&nodeType,
                                                            &parameters);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "uu",
                      &status,
                      &nodeType);
    appendEmberNetworkParameters(&parameters);
    break;
  }

  case EZSP_GET_NEXT_BEACON: {
    // Response arguments.
    EmberStatus status;
    EmberBeaconData beacon;
    // Callback.
    status = emberGetNextBeacon(&beacon);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberBeaconData(&beacon);
    break;
  }

  case EZSP_GET_NUM_STORED_BEACONS: {
    // Response arguments.
    uint8_t numBeacons;
    // Callback.
    numBeacons = emberGetNumStoredBeacons();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &numBeacons);
    break;
  }

  case EZSP_GET_PARENT_CHILD_PARAMETERS: {
    // Response arguments.
    uint8_t childCount;
    uint8_t parentEui64Length = 8;
    EmberEUI64 parentEui64;
    EmberNodeId parentNodeId;
    // Callback.
    childCount = emberAfEzspGetParentChildParametersCommandCallback(parentEui64,
                                                                    &parentNodeId);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "ubv",
                      &childCount,
                      &parentEui64,
                      &parentEui64Length,
                      &parentNodeId);
    break;
  }

  case EZSP_GET_RADIO_PARAMETERS: {
    // Command arguments.
    uint8_t phyIndex;
    // Response arguments.
    EmberStatus status;
    EmberMultiPhyRadioParameters parameters;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &phyIndex);
    // Callback.
    status = emberGetRadioParameters(phyIndex,
                                     &parameters);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberMultiPhyRadioParameters(&parameters);
    break;
  }

  case EZSP_GET_ROUTE_TABLE_ENTRY: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    EmberRouteTableEntry value;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberGetRouteTableEntry(index,
                                     &value);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberRouteTableEntry(&value);
    break;
  }

  case EZSP_GET_ROUTING_SHORTCUT_THRESHOLD: {
    // Response arguments.
    uint8_t routingShortcutThresh;
    // Callback.
    routingShortcutThresh = emberAfEzspGetRoutingShortcutThresholdCommandCallback();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &routingShortcutThresh);
    break;
  }

  case EZSP_GET_SOURCE_ROUTE_TABLE_ENTRY: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    EmberNodeId destination;
    uint8_t closerIndex;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberAfEzspGetSourceRouteTableEntryCommandCallback(index,
                                                                &destination,
                                                                &closerIndex);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "uvu",
                      &status,
                      &destination,
                      &closerIndex);
    break;
  }

  case EZSP_GET_SOURCE_ROUTE_TABLE_FILLED_SIZE: {
    // Response arguments.
    uint8_t sourceRouteTableFilledSize;
    // Callback.
    sourceRouteTableFilledSize = emberAfEzspGetSourceRouteTableFilledSizeCommandCallback();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &sourceRouteTableFilledSize);
    break;
  }

  case EZSP_GET_SOURCE_ROUTE_TABLE_TOTAL_SIZE: {
    // Response arguments.
    uint8_t sourceRouteTableTotalSize;
    // Callback.
    sourceRouteTableTotalSize = emberAfEzspGetSourceRouteTableTotalSizeCommandCallback();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &sourceRouteTableTotalSize);
    break;
  }

  case EZSP_JOIN_NETWORK: {
    // Command arguments.
    EmberNodeType nodeType;
    EmberNetworkParameters parameters;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &nodeType);
    fetchEmberNetworkParameters(&parameters);
    // Callback.
    status = emberJoinNetwork(nodeType,
                              &parameters);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_JOIN_NETWORK_DIRECTLY: {
    // Command arguments.
    EmberNodeType localNodeType;
    EmberBeaconData beacon;
    int8_t radioTxPower;
    bool clearBeaconsAfterNetworkUp;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &localNodeType);
    fetchEmberBeaconData(&beacon);
    emAfFetchOrAppend(true /* FETCH */,
                      "su",
                      &radioTxPower,
                      &clearBeaconsAfterNetworkUp);
    // Callback.
    status = emberJoinNetworkDirectly(localNodeType,
                                      &beacon,
                                      radioTxPower,
                                      clearBeaconsAfterNetworkUp);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_LEAVE_NETWORK: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberLeaveNetwork();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MULTI_PHY_SET_RADIO_CHANNEL: {
    // Command arguments.
    uint8_t phyIndex;
    uint8_t page;
    uint8_t channel;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uuu",
                      &phyIndex,
                      &page,
                      &channel);
    // Callback.
    status = emberMultiPhySetRadioChannel(phyIndex,
                                          page,
                                          channel);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MULTI_PHY_SET_RADIO_POWER: {
    // Command arguments.
    uint8_t phyIndex;
    int8_t power;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "us",
                      &phyIndex,
                      &power);
    // Callback.
    status = emberMultiPhySetRadioPower(phyIndex,
                                        power);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MULTI_PHY_START: {
    // Command arguments.
    uint8_t phyIndex;
    uint8_t page;
    uint8_t channel;
    int8_t power;
    EmberMultiPhyNwkConfig bitmask;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uuusu",
                      &phyIndex,
                      &page,
                      &channel,
                      &power,
                      &bitmask);
    // Callback.
    status = emberMultiPhyStart(phyIndex,
                                page,
                                channel,
                                power,
                                bitmask);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MULTI_PHY_STOP: {
    // Command arguments.
    uint8_t phyIndex;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &phyIndex);
    // Callback.
    status = emberMultiPhyStop(phyIndex);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_NEIGHBOR_COUNT: {
    // Response arguments.
    uint8_t value;
    // Callback.
    value = emberNeighborCount();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &value);
    break;
  }

  case EZSP_NETWORK_INIT: {
    // Command arguments.
    EmberNetworkInitStruct networkInitStruct;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberNetworkInitStruct(&networkInitStruct);
    // Callback.
    status = emberNetworkInit(&networkInitStruct);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_NETWORK_STATE: {
    // Response arguments.
    EmberNetworkStatus status;
    // Callback.
    status = emberNetworkState();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_PERMIT_JOINING: {
    // Command arguments.
    uint8_t duration;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &duration);
    // Callback.
    status = emberPermitJoining(duration);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SEND_LINK_POWER_DELTA_REQUEST: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberSendLinkPowerDeltaRequest();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_BROKEN_ROUTE_ERROR_CODE: {
    // Command arguments.
    uint8_t errorCode;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &errorCode);
    // Callback.
    status = emberAfEzspSetBrokenRouteErrorCodeCommandCallback(errorCode);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_CONCENTRATOR: {
    // Command arguments.
    bool on;
    uint16_t concentratorType;
    uint16_t minTime;
    uint16_t maxTime;
    uint8_t routeErrorThreshold;
    uint8_t deliveryFailureThreshold;
    uint8_t maxHops;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uvvvuuu",
                      &on,
                      &concentratorType,
                      &minTime,
                      &maxTime,
                      &routeErrorThreshold,
                      &deliveryFailureThreshold,
                      &maxHops);
    // Callback.
    status = emberAfPluginEzspZigbeeProSetConcentratorCommandCallback(on,
                                                                      concentratorType,
                                                                      minTime,
                                                                      maxTime,
                                                                      routeErrorThreshold,
                                                                      deliveryFailureThreshold,
                                                                      maxHops);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_DUTY_CYCLE_LIMITS_IN_STACK: {
    // Command arguments.
    EmberDutyCycleLimits limits;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberDutyCycleLimits(&limits);
    // Callback.
    status = emberSetDutyCycleLimitsInStack(&limits);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_MANUFACTURER_CODE: {
    // Command arguments.
    uint16_t code;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "v",
                      &code);
    // Callback.
    emberSetManufacturerCode(code);
    break;
  }

  case EZSP_SET_POWER_DESCRIPTOR: {
    // Command arguments.
    uint16_t descriptor;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "v",
                      &descriptor);
    // Callback.
    emberSetPowerDescriptor(descriptor);
    break;
  }

  case EZSP_SET_RADIO_CHANNEL: {
    // Command arguments.
    uint8_t channel;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &channel);
    // Callback.
    status = emberSetRadioChannel(channel);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_RADIO_POWER: {
    // Command arguments.
    int8_t power;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "s",
                      &power);
    // Callback.
    status = emberSetRadioPower(power);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_ROUTING_SHORTCUT_THRESHOLD: {
    // Command arguments.
    uint8_t costThresh;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &costThresh);
    // Callback.
    status = emberAfEzspSetRoutingShortcutThresholdCommandCallback(costThresh);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_START_SCAN: {
    // Command arguments.
    EzspNetworkScanType scanType;
    uint32_t channelMask;
    uint8_t duration;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uwu",
                      &scanType,
                      &channelMask,
                      &duration);
    // Callback.
    status = emberStartScan(scanType,
                            channelMask,
                            duration);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_STOP_SCAN: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberStopScan();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

// -----------------------------------------------------------------------------
// Messaging Frames

  case EZSP_ADDRESS_TABLE_ENTRY_IS_ACTIVE: {
    // Command arguments.
    uint8_t addressTableIndex;
    // Response arguments.
    bool active;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &addressTableIndex);
    // Callback.
    active = emberAddressTableEntryIsActive(addressTableIndex);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &active);
    break;
  }

  case EZSP_GET_ADDRESS_TABLE_REMOTE_EUI64: {
    // Command arguments.
    uint8_t addressTableIndex;
    // Response arguments.
    uint8_t eui64Length = 8;
    EmberEUI64 eui64;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &addressTableIndex);
    // Callback.
    emberGetAddressTableRemoteEui64(addressTableIndex,
                                    eui64);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "b",
                      &eui64,
                      &eui64Length);
    break;
  }

  case EZSP_GET_ADDRESS_TABLE_REMOTE_NODE_ID: {
    // Command arguments.
    uint8_t addressTableIndex;
    // Response arguments.
    EmberNodeId nodeId;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &addressTableIndex);
    // Callback.
    nodeId = emberGetAddressTableRemoteNodeId(addressTableIndex);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "v",
                      &nodeId);
    break;
  }

  case EZSP_GET_BEACON_CLASSIFICATION_PARAMS: {
    // Response arguments.
    EmberStatus status;
    EmberBeaconClassificationParams param;
    // Callback.
    status = emberGetBeaconClassificationParams(&param);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberBeaconClassificationParams(&param);
    break;
  }

  case EZSP_GET_EXTENDED_TIMEOUT: {
    // Command arguments.
    uint8_t remoteEui64Length = 8;
    EmberEUI64 remoteEui64;
    // Response arguments.
    bool extendedTimeout;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "b",
                      &remoteEui64,
                      &remoteEui64Length);
    // Callback.
    extendedTimeout = emberGetExtendedTimeout(remoteEui64);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &extendedTimeout);
    break;
  }

  case EZSP_GET_MULTICAST_TABLE_ENTRY: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    EmberMulticastTableEntry value;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberAfEzspGetMulticastTableEntryCommandCallback(index,
                                                              &value);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberMulticastTableEntry(&value);
    break;
  }

  case EZSP_LOOKUP_EUI64_BY_NODE_ID: {
    // Command arguments.
    EmberNodeId nodeId;
    // Response arguments.
    EmberStatus status;
    uint8_t eui64Length = 8;
    EmberEUI64 eui64;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "v",
                      &nodeId);
    // Callback.
    status = emberLookupEui64ByNodeId(nodeId,
                                      eui64);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "ub",
                      &status,
                      &eui64,
                      &eui64Length);
    break;
  }

  case EZSP_LOOKUP_NODE_ID_BY_EUI64: {
    // Command arguments.
    uint8_t eui64Length = 8;
    EmberEUI64 eui64;
    // Response arguments.
    EmberNodeId nodeId;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "b",
                      &eui64,
                      &eui64Length);
    // Callback.
    nodeId = emberLookupNodeIdByEui64(eui64);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "v",
                      &nodeId);
    break;
  }

  case EZSP_MAXIMUM_PAYLOAD_LENGTH: {
    // Response arguments.
    uint8_t apsLength;
    // Callback.
    apsLength = emberMaximumApsPayloadLength();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &apsLength);
    break;
  }

  case EZSP_POLL_FOR_DATA: {
    // Command arguments.
    uint16_t interval;
    EmberEventUnits units;
    uint8_t failureLimit;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vuu",
                      &interval,
                      &units,
                      &failureLimit);
    // Callback.
    status = emberAfEzspPollForDataCommandCallback(interval,
                                                   units,
                                                   failureLimit);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_PROXY_BROADCAST: {
    // Command arguments.
    EmberNodeId source;
    EmberNodeId destination;
    uint8_t nwkSequence;
    EmberApsFrame apsFrame;
    uint8_t radius;
    uint8_t messageTag;
    uint8_t messageLength;
    uint8_t* messageContents;
    // Response arguments.
    EmberStatus status;
    uint8_t apsSequence;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vvu",
                      &source,
                      &destination,
                      &nwkSequence);
    fetchEmberApsFrame(&apsFrame);
    emAfFetchOrAppend(true /* FETCH */,
                      "uuup",
                      &radius,
                      &messageTag,
                      &messageLength,
                      &messageContents,
                      &messageLength);
    // Callback.
    status = emberAfEzspProxyBroadcastCommandCallback(source,
                                                      destination,
                                                      nwkSequence,
                                                      &apsFrame,
                                                      radius,
                                                      messageTag,
                                                      messageLength,
                                                      messageContents,
                                                      &apsSequence);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "uu",
                      &status,
                      &apsSequence);
    break;
  }

  case EZSP_REPLACE_ADDRESS_TABLE_ENTRY: {
    // Command arguments.
    uint8_t addressTableIndex;
    uint8_t newEui64Length = 8;
    EmberEUI64 newEui64;
    EmberNodeId newId;
    bool newExtendedTimeout;
    // Response arguments.
    EmberStatus status;
    uint8_t oldEui64Length = 8;
    EmberEUI64 oldEui64;
    EmberNodeId oldId;
    bool oldExtendedTimeout;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "ubvu",
                      &addressTableIndex,
                      &newEui64,
                      &newEui64Length,
                      &newId,
                      &newExtendedTimeout);
    // Callback.
    status = emberAfEzspReplaceAddressTableEntryCommandCallback(addressTableIndex,
                                                                newEui64,
                                                                newId,
                                                                newExtendedTimeout,
                                                                oldEui64,
                                                                &oldId,
                                                                &oldExtendedTimeout);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "ubvu",
                      &status,
                      &oldEui64,
                      &oldEui64Length,
                      &oldId,
                      &oldExtendedTimeout);
    break;
  }

  case EZSP_SEND_BROADCAST: {
    // Command arguments.
    EmberNodeId destination;
    EmberApsFrame apsFrame;
    uint8_t radius;
    uint8_t messageTag;
    uint8_t messageLength;
    uint8_t* messageContents;
    // Response arguments.
    EmberStatus status;
    uint8_t sequence;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "v",
                      &destination);
    fetchEmberApsFrame(&apsFrame);
    emAfFetchOrAppend(true /* FETCH */,
                      "uuup",
                      &radius,
                      &messageTag,
                      &messageLength,
                      &messageContents,
                      &messageLength);
    // Callback.
    status = emberAfEzspSendBroadcastCommandCallback(destination,
                                                     &apsFrame,
                                                     radius,
                                                     messageTag,
                                                     messageLength,
                                                     messageContents,
                                                     &sequence);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "uu",
                      &status,
                      &sequence);
    break;
  }

  case EZSP_SEND_MANY_TO_ONE_ROUTE_REQUEST: {
    // Command arguments.
    uint16_t concentratorType;
    uint8_t radius;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vu",
                      &concentratorType,
                      &radius);
    // Callback.
    status = emberSendManyToOneRouteRequest(concentratorType,
                                            radius);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SEND_MULTICAST: {
    // Command arguments.
    EmberApsFrame apsFrame;
    uint8_t hops;
    uint8_t nonmemberRadius;
    uint8_t messageTag;
    uint8_t messageLength;
    uint8_t* messageContents;
    // Response arguments.
    EmberStatus status;
    uint8_t sequence;
    // Fetch.
    fetchEmberApsFrame(&apsFrame);
    emAfFetchOrAppend(true /* FETCH */,
                      "uuuup",
                      &hops,
                      &nonmemberRadius,
                      &messageTag,
                      &messageLength,
                      &messageContents,
                      &messageLength);
    // Callback.
    status = emberAfEzspSendMulticastCommandCallback(&apsFrame,
                                                     hops,
                                                     nonmemberRadius,
                                                     messageTag,
                                                     messageLength,
                                                     messageContents,
                                                     &sequence);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "uu",
                      &status,
                      &sequence);
    break;
  }

  case EZSP_SEND_MULTICAST_WITH_ALIAS: {
    // Command arguments.
    EmberApsFrame apsFrame;
    uint8_t hops;
    uint8_t nonmemberRadius;
    uint16_t alias;
    uint8_t nwkSequence;
    uint8_t messageTag;
    uint8_t messageLength;
    uint8_t* messageContents;
    // Response arguments.
    EmberStatus status;
    uint8_t sequence;
    // Fetch.
    fetchEmberApsFrame(&apsFrame);
    emAfFetchOrAppend(true /* FETCH */,
                      "uuvuuup",
                      &hops,
                      &nonmemberRadius,
                      &alias,
                      &nwkSequence,
                      &messageTag,
                      &messageLength,
                      &messageContents,
                      &messageLength);
    // Callback.
    status = emberAfEzspSendMulticastWithAliasCommandCallback(&apsFrame,
                                                              hops,
                                                              nonmemberRadius,
                                                              alias,
                                                              nwkSequence,
                                                              messageTag,
                                                              messageLength,
                                                              messageContents,
                                                              &sequence);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "uu",
                      &status,
                      &sequence);
    break;
  }

  case EZSP_SEND_RAW_MESSAGE: {
    // Command arguments.
    uint8_t messageLength;
    uint8_t* messageContents;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "up",
                      &messageLength,
                      &messageContents,
                      &messageLength);
    // Callback.
    status = emberAfEzspSendRawMessageCommandCallback(messageLength,
                                                      messageContents);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SEND_REPLY: {
    // Command arguments.
    EmberNodeId sender;
    EmberApsFrame apsFrame;
    uint8_t messageLength;
    uint8_t* messageContents;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "v",
                      &sender);
    fetchEmberApsFrame(&apsFrame);
    emAfFetchOrAppend(true /* FETCH */,
                      "up",
                      &messageLength,
                      &messageContents,
                      &messageLength);
    // Callback.
    status = emberAfEzspSendReplyCommandCallback(sender,
                                                 &apsFrame,
                                                 messageLength,
                                                 messageContents);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SEND_UNICAST: {
    // Command arguments.
    EmberOutgoingMessageType type;
    EmberNodeId indexOrDestination;
    EmberApsFrame apsFrame;
    uint8_t messageTag;
    uint8_t messageLength;
    uint8_t* messageContents;
    // Response arguments.
    EmberStatus status;
    uint8_t sequence;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uv",
                      &type,
                      &indexOrDestination);
    fetchEmberApsFrame(&apsFrame);
    emAfFetchOrAppend(true /* FETCH */,
                      "uup",
                      &messageTag,
                      &messageLength,
                      &messageContents,
                      &messageLength);
    // Callback.
    status = emberAfEzspSendUnicastCommandCallback(type,
                                                   indexOrDestination,
                                                   &apsFrame,
                                                   messageTag,
                                                   messageLength,
                                                   messageContents,
                                                   &sequence);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "uu",
                      &status,
                      &sequence);
    break;
  }

  case EZSP_SET_ADDRESS_TABLE_REMOTE_EUI64: {
    // Command arguments.
    uint8_t addressTableIndex;
    uint8_t eui64Length = 8;
    EmberEUI64 eui64;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "ub",
                      &addressTableIndex,
                      &eui64,
                      &eui64Length);
    // Callback.
    status = emberSetAddressTableRemoteEui64(addressTableIndex,
                                             eui64);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_ADDRESS_TABLE_REMOTE_NODE_ID: {
    // Command arguments.
    uint8_t addressTableIndex;
    EmberNodeId id;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uv",
                      &addressTableIndex,
                      &id);
    // Callback.
    emberSetAddressTableRemoteNodeId(addressTableIndex,
                                     id);
    break;
  }

  case EZSP_SET_BEACON_CLASSIFICATION_PARAMS: {
    // Response arguments.
    EmberStatus status;
    EmberBeaconClassificationParams param;
    // Callback.
    status = emberSetBeaconClassificationParams(&param);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberBeaconClassificationParams(&param);
    break;
  }

  case EZSP_SET_EXTENDED_TIMEOUT: {
    // Command arguments.
    uint8_t remoteEui64Length = 8;
    EmberEUI64 remoteEui64;
    bool extendedTimeout;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "bu",
                      &remoteEui64,
                      &remoteEui64Length,
                      &extendedTimeout);
    // Callback.
    emberSetExtendedTimeout(remoteEui64,
                            extendedTimeout);
    break;
  }

  case EZSP_SET_MAC_POLL_CCA_WAIT_TIME: {
    // Command arguments.
    uint8_t waitBeforeRetryIntervalMs;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &waitBeforeRetryIntervalMs);
    // Callback.
    emberSetMacPollCcaWaitTime(waitBeforeRetryIntervalMs);
    break;
  }

  case EZSP_SET_MULTICAST_TABLE_ENTRY: {
    // Command arguments.
    uint8_t index;
    EmberMulticastTableEntry value;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    fetchEmberMulticastTableEntry(&value);
    // Callback.
    status = emberAfEzspSetMulticastTableEntryCommandCallback(index,
                                                              &value);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_SOURCE_ROUTE: {
    // Command arguments.
    EmberNodeId destination;
    uint8_t relayCount;
    uint16_t* relayList;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vup",
                      &destination,
                      &relayCount,
                      &relayList,
                      &relayCount);
    // Callback.
    status = emberAfEzspSetSourceRouteCommandCallback(destination,
                                                      relayCount,
                                                      relayList);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_UNICAST_CURRENT_NETWORK_KEY: {
    // Command arguments.
    EmberNodeId targetShort;
    uint8_t targetLongLength = 8;
    EmberEUI64 targetLong;
    EmberNodeId parentShortId;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vbv",
                      &targetShort,
                      &targetLong,
                      &targetLongLength,
                      &parentShortId);
    // Callback.
    status = emberAfEzspUnicastCurrentNetworkKeyCommandCallback(targetShort,
                                                                targetLong,
                                                                parentShortId);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_WRITE_NODE_DATA: {
    // Command arguments.
    bool erase;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &erase);
    // Callback.
    status = emberWriteNodeData(erase);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

// -----------------------------------------------------------------------------
// ZLL

  case EZSP_GET_LOGICAL_CHANNEL: {
    // Response arguments.
    uint8_t logicalChannel;
    // Callback.
    logicalChannel = emberAfEzspGetLogicalChannelCommandCallback();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &logicalChannel);
    break;
  }

  case EZSP_GET_ZLL_PRIMARY_CHANNEL_MASK: {
    // Response arguments.
    uint32_t zllPrimaryChannelMask;
    // Callback.
    zllPrimaryChannelMask = emberGetZllPrimaryChannelMask();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "w",
                      &zllPrimaryChannelMask);
    break;
  }

  case EZSP_GET_ZLL_SECONDARY_CHANNEL_MASK: {
    // Response arguments.
    uint32_t zllSecondaryChannelMask;
    // Callback.
    zllSecondaryChannelMask = emberGetZllSecondaryChannelMask();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "w",
                      &zllSecondaryChannelMask);
    break;
  }

  case EZSP_IS_ZLL_NETWORK: {
    // Response arguments.
    bool isZllNetwork;
    // Callback.
    isZllNetwork = emberIsZllNetwork();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &isZllNetwork);
    break;
  }

  case EZSP_SET_LOGICAL_AND_RADIO_CHANNEL: {
    // Command arguments.
    uint8_t radioChannel;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &radioChannel);
    // Callback.
    status = emberAfEzspSetLogicalAndRadioChannelCommandCallback(radioChannel);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_ZLL_ADDITIONAL_STATE: {
    // Command arguments.
    uint16_t state;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "v",
                      &state);
    // Callback.
    emberSetZllAdditionalState(state);
    break;
  }

  case EZSP_SET_ZLL_NODE_TYPE: {
    // Command arguments.
    EmberNodeType nodeType;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &nodeType);
    // Callback.
    emberSetZllNodeType(nodeType);
    break;
  }

  case EZSP_SET_ZLL_PRIMARY_CHANNEL_MASK: {
    // Command arguments.
    uint32_t zllPrimaryChannelMask;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "w",
                      &zllPrimaryChannelMask);
    // Callback.
    emberSetZllPrimaryChannelMask(zllPrimaryChannelMask);
    break;
  }

  case EZSP_SET_ZLL_SECONDARY_CHANNEL_MASK: {
    // Command arguments.
    uint32_t zllSecondaryChannelMask;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "w",
                      &zllSecondaryChannelMask);
    // Callback.
    emberSetZllSecondaryChannelMask(zllSecondaryChannelMask);
    break;
  }

  case EZSP_ZLL_CLEAR_TOKENS: {
    // Callback.
    emberZllClearTokens();
    break;
  }

  case EZSP_ZLL_GET_TOKENS: {
    // Response arguments.
    EmberTokTypeStackZllData data;
    EmberTokTypeStackZllSecurity security;
    // Callback.
    emberZllGetTokensStackZll(&data,
                              &security);
    // Append.
    appendEmberTokTypeStackZllData(&data);
    appendEmberTokTypeStackZllSecurity(&security);
    break;
  }

  case EZSP_ZLL_NETWORK_OPS: {
    // Command arguments.
    EmberZllNetwork networkInfo;
    EzspZllNetworkOperation op;
    int8_t radioTxPower;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberZllNetwork(&networkInfo);
    emAfFetchOrAppend(true /* FETCH */,
                      "us",
                      &op,
                      &radioTxPower);
    // Callback.
    status = emberAfEzspZllNetworkOpsCommandCallback(&networkInfo,
                                                     op,
                                                     radioTxPower);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_ZLL_OPERATION_IN_PROGRESS: {
    // Response arguments.
    bool zllOperationInProgress;
    // Callback.
    zllOperationInProgress = emberZllOperationInProgress();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &zllOperationInProgress);
    break;
  }

  case EZSP_ZLL_RX_ON_WHEN_IDLE_GET_ACTIVE: {
    // Response arguments.
    bool zllRxOnWhenIdleGetActive;
    // Callback.
    zllRxOnWhenIdleGetActive = emberZllRxOnWhenIdleGetActive();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &zllRxOnWhenIdleGetActive);
    break;
  }

  case EZSP_ZLL_SET_DATA_TOKEN: {
    // Command arguments.
    EmberTokTypeStackZllData data;
    // Fetch.
    fetchEmberTokTypeStackZllData(&data);
    // Callback.
    emberZllSetTokenStackZllData(&data);
    break;
  }

  case EZSP_ZLL_SET_INITIAL_SECURITY_STATE: {
    // Command arguments.
    EmberKeyData networkKey;
    EmberZllInitialSecurityState securityState;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberKeyData(&networkKey);
    fetchEmberZllInitialSecurityState(&securityState);
    // Callback.
    status = emberZllSetInitialSecurityState(&networkKey,
                                             &securityState);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_ZLL_SET_NON_ZLL_NETWORK: {
    // Callback.
    emberZllSetNonZllNetwork();
    break;
  }

  case EZSP_ZLL_SET_RADIO_IDLE_MODE: {
    // Command arguments.
    EmberRadioPowerMode mode;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &mode);
    // Callback.
    emberZllSetRadioIdleMode(mode);
    break;
  }

  case EZSP_ZLL_SET_RX_ON_WHEN_IDLE: {
    // Command arguments.
    uint32_t durationMs;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "w",
                      &durationMs);
    // Callback.
    status = emberZllSetRxOnWhenIdle(durationMs);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_ZLL_SET_SECURITY_STATE_WITHOUT_KEY: {
    // Command arguments.
    EmberZllInitialSecurityState securityState;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberZllInitialSecurityState(&securityState);
    // Callback.
    status = emberZllSetSecurityStateWithoutKey(&securityState);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_ZLL_START_SCAN: {
    // Command arguments.
    uint32_t channelMask;
    int8_t radioPowerForScan;
    EmberNodeType nodeType;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "wsu",
                      &channelMask,
                      &radioPowerForScan,
                      &nodeType);
    // Callback.
    status = emberZllStartScan(channelMask,
                               radioPowerForScan,
                               nodeType);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

// -----------------------------------------------------------------------------
// Security Frames

  case EZSP_ADD_OR_UPDATE_KEY_TABLE_ENTRY: {
    // Command arguments.
    uint8_t addressLength = 8;
    EmberEUI64 address;
    bool linkKey;
    EmberKeyData keyData;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "bu",
                      &address,
                      &addressLength,
                      &linkKey);
    fetchEmberKeyData(&keyData);
    // Callback.
    status = emberAddOrUpdateKeyTableEntry(address,
                                           linkKey,
                                           &keyData);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_ADD_TRANSIENT_LINK_KEY: {
    // Command arguments.
    uint8_t partnerLength = 8;
    EmberEUI64 partner;
    EmberKeyData transientKey;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "b",
                      &partner,
                      &partnerLength);
    fetchEmberKeyData(&transientKey);
    // Callback.
    status = emberAfEzspAddTransientLinkKeyCommandCallback(partner,
                                                           &transientKey);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_CLEAR_KEY_TABLE: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberClearKeyTable();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_CLEAR_TRANSIENT_LINK_KEYS: {
    // Callback.
    emberClearTransientLinkKeys();
    break;
  }

  case EZSP_ERASE_KEY_TABLE_ENTRY: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberEraseKeyTableEntry(index);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_FIND_KEY_TABLE_ENTRY: {
    // Command arguments.
    uint8_t addressLength = 8;
    EmberEUI64 address;
    bool linkKey;
    // Response arguments.
    uint8_t index;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "bu",
                      &address,
                      &addressLength,
                      &linkKey);
    // Callback.
    index = emberFindKeyTableEntry(address,
                                   linkKey);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &index);
    break;
  }

  case EZSP_GET_CURRENT_SECURITY_STATE: {
    // Response arguments.
    EmberStatus status;
    EmberCurrentSecurityState state;
    // Callback.
    status = emberGetCurrentSecurityState(&state);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberCurrentSecurityState(&state);
    break;
  }

  case EZSP_GET_KEY: {
    // Command arguments.
    EmberKeyType keyType;
    // Response arguments.
    EmberStatus status;
    EmberKeyStruct keyStruct;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &keyType);
    // Callback.
    status = emberGetKey(keyType,
                         &keyStruct);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberKeyStruct(&keyStruct);
    break;
  }

  case EZSP_GET_KEY_TABLE_ENTRY: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    EmberKeyStruct keyStruct;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberGetKeyTableEntry(index,
                                   &keyStruct);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberKeyStruct(&keyStruct);
    break;
  }

  case EZSP_GET_TRANSIENT_KEY_TABLE_ENTRY: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    EmberTransientKeyData transientKeyData;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberGetTransientKeyTableEntry(index,
                                            &transientKeyData);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberTransientKeyData(&transientKeyData);
    break;
  }

  case EZSP_GET_TRANSIENT_LINK_KEY: {
    // Command arguments.
    uint8_t euiLength = 8;
    EmberEUI64 eui;
    // Response arguments.
    EmberStatus status;
    EmberTransientKeyData transientKeyData;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "b",
                      &eui,
                      &euiLength);
    // Callback.
    status = emberAfEzspGetTransientLinkKeyCommandCallback(eui,
                                                           &transientKeyData);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberTransientKeyData(&transientKeyData);
    break;
  }

  case EZSP_REQUEST_LINK_KEY: {
    // Command arguments.
    uint8_t partnerLength = 8;
    EmberEUI64 partner;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "b",
                      &partner,
                      &partnerLength);
    // Callback.
    status = emberRequestLinkKey(partner);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SEND_TRUST_CENTER_LINK_KEY: {
    // Command arguments.
    EmberNodeId destinationNodeId;
    uint8_t destinationEui64Length = 8;
    EmberEUI64 destinationEui64;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vb",
                      &destinationNodeId,
                      &destinationEui64,
                      &destinationEui64Length);
    // Callback.
    status = emberSendTrustCenterLinkKey(destinationNodeId,
                                         destinationEui64);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_INITIAL_SECURITY_STATE: {
    // Command arguments.
    EmberInitialSecurityState state;
    // Response arguments.
    EmberStatus success;
    // Fetch.
    fetchEmberInitialSecurityState(&state);
    // Callback.
    success = emberSetInitialSecurityState(&state);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &success);
    break;
  }

  case EZSP_SET_KEY_TABLE_ENTRY: {
    // Command arguments.
    uint8_t index;
    uint8_t addressLength = 8;
    EmberEUI64 address;
    bool linkKey;
    EmberKeyData keyData;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "ubu",
                      &index,
                      &address,
                      &addressLength,
                      &linkKey);
    fetchEmberKeyData(&keyData);
    // Callback.
    status = emberSetKeyTableEntry(index,
                                   address,
                                   linkKey,
                                   &keyData);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_UPDATE_TC_LINK_KEY: {
    // Command arguments.
    uint8_t maxAttempts;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &maxAttempts);
    // Callback.
    status = emberUpdateTcLinkKey(maxAttempts);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

// -----------------------------------------------------------------------------
// Trust Center Frames

  case EZSP_AES_MMO_HASH: {
    // Command arguments.
    EmberAesMmoHashContext context;
    bool finalize;
    uint8_t length;
    uint8_t* data;
    // Response arguments.
    EmberStatus status;
    EmberAesMmoHashContext returnContext;
    // Fetch.
    fetchEmberAesMmoHashContext(&context);
    emAfFetchOrAppend(true /* FETCH */,
                      "uup",
                      &finalize,
                      &length,
                      &data,
                      &length);
    // Callback.
    status = emberAfEzspAesMmoHashCommandCallback(&context,
                                                  finalize,
                                                  length,
                                                  data,
                                                  &returnContext);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberAesMmoHashContext(&returnContext);
    break;
  }

  case EZSP_BECOME_TRUST_CENTER: {
    // Command arguments.
    EmberKeyData newNetworkKey;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberKeyData(&newNetworkKey);
    // Callback.
    status = emberBecomeTrustCenter(&newNetworkKey);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_BROADCAST_NETWORK_KEY_SWITCH: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberBroadcastNetworkKeySwitch();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_BROADCAST_NEXT_NETWORK_KEY: {
    // Command arguments.
    EmberKeyData key;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberKeyData(&key);
    // Callback.
    status = emberBroadcastNextNetworkKey(&key);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_REMOVE_DEVICE: {
    // Command arguments.
    EmberNodeId destShort;
    uint8_t destLongLength = 8;
    EmberEUI64 destLong;
    uint8_t targetLongLength = 8;
    EmberEUI64 targetLong;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vbb",
                      &destShort,
                      &destLong,
                      &destLongLength,
                      &targetLong,
                      &targetLongLength);
    // Callback.
    status = emberSendRemoveDevice(destShort,
                                   destLong,
                                   targetLong);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_UNICAST_NWK_KEY_UPDATE: {
    // Command arguments.
    EmberNodeId destShort;
    uint8_t destLongLength = 8;
    EmberEUI64 destLong;
    EmberKeyData key;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vb",
                      &destShort,
                      &destLong,
                      &destLongLength);
    fetchEmberKeyData(&key);
    // Callback.
    status = emberSendUnicastNetworkKeyUpdate(destShort,
                                              destLong,
                                              &key);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

// -----------------------------------------------------------------------------
// Green Power

  case EZSP_D_GP_SEND: {
    // Command arguments.
    bool action;
    bool useCca;
    EmberGpAddress addr;
    uint8_t gpdCommandId;
    uint8_t gpdAsduLength;
    uint8_t* gpdAsdu;
    uint8_t gpepHandle;
    uint16_t gpTxQueueEntryLifetimeMs;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uu",
                      &action,
                      &useCca);
    fetchEmberGpAddress(&addr);
    emAfFetchOrAppend(true /* FETCH */,
                      "uupuv",
                      &gpdCommandId,
                      &gpdAsduLength,
                      &gpdAsdu,
                      &gpdAsduLength,
                      &gpepHandle,
                      &gpTxQueueEntryLifetimeMs);
    // Callback.
    status = emberDGpSend(action,
                          useCca,
                          &addr,
                          gpdCommandId,
                          gpdAsduLength,
                          gpdAsdu,
                          gpepHandle,
                          gpTxQueueEntryLifetimeMs);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_GP_PROXY_TABLE_GET_ENTRY: {
    // Command arguments.
    uint8_t proxyIndex;
    // Response arguments.
    EmberStatus status;
    EmberGpProxyTableEntry entry;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &proxyIndex);
    // Callback.
    status = emberGpProxyTableGetEntry(proxyIndex,
                                       &entry);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberGpProxyTableEntry(&entry);
    break;
  }

  case EZSP_GP_PROXY_TABLE_LOOKUP: {
    // Command arguments.
    EmberGpAddress addr;
    // Response arguments.
    uint8_t index;
    // Fetch.
    fetchEmberGpAddress(&addr);
    // Callback.
    index = emberGpProxyTableLookup(&addr);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &index);
    break;
  }

  case EZSP_GP_PROXY_TABLE_PROCESS_GP_PAIRING: {
    // Command arguments.
    uint32_t options;
    EmberGpAddress addr;
    uint8_t commMode;
    uint16_t sinkNetworkAddress;
    uint16_t sinkGroupId;
    uint16_t assignedAlias;
    uint8_t sinkIeeeAddressLength = 8;
    uint8_t sinkIeeeAddress[8];
    EmberKeyData gpdKey;
    uint32_t gpdSecurityFrameCounter;
    uint8_t forwardingRadius;
    // Response arguments.
    bool gpPairingAdded;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "w",
                      &options);
    fetchEmberGpAddress(&addr);
    emAfFetchOrAppend(true /* FETCH */,
                      "uvvvb",
                      &commMode,
                      &sinkNetworkAddress,
                      &sinkGroupId,
                      &assignedAlias,
                      &sinkIeeeAddress,
                      &sinkIeeeAddressLength);
    fetchEmberKeyData(&gpdKey);
    emAfFetchOrAppend(true /* FETCH */,
                      "wu",
                      &gpdSecurityFrameCounter,
                      &forwardingRadius);
    // Callback.
    gpPairingAdded = emberGpProxyTableProcessGpPairing(options,
                                                       &addr,
                                                       commMode,
                                                       sinkNetworkAddress,
                                                       sinkGroupId,
                                                       assignedAlias,
                                                       sinkIeeeAddress,
                                                       &gpdKey,
                                                       gpdSecurityFrameCounter,
                                                       forwardingRadius);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &gpPairingAdded);
    break;
  }

  case EZSP_GP_SINK_TABLE_CLEAR_ALL: {
    // Callback.
    emberGpSinkTableClearAll();
    break;
  }

  case EZSP_GP_SINK_TABLE_FIND_OR_ALLOCATE_ENTRY: {
    // Command arguments.
    EmberGpAddress addr;
    // Response arguments.
    uint8_t index;
    // Fetch.
    fetchEmberGpAddress(&addr);
    // Callback.
    index = emberGpSinkTableFindOrAllocateEntry(&addr);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &index);
    break;
  }

  case EZSP_GP_SINK_TABLE_GET_ENTRY: {
    // Command arguments.
    uint8_t sinkIndex;
    // Response arguments.
    EmberStatus status;
    EmberGpSinkTableEntry entry;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &sinkIndex);
    // Callback.
    status = emberGpSinkTableGetEntry(sinkIndex,
                                      &entry);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberGpSinkTableEntry(&entry);
    break;
  }

  case EZSP_GP_SINK_TABLE_INIT: {
    // Callback.
    emberGpSinkTableInit();
    break;
  }

  case EZSP_GP_SINK_TABLE_LOOKUP: {
    // Command arguments.
    EmberGpAddress addr;
    // Response arguments.
    uint8_t index;
    // Fetch.
    fetchEmberGpAddress(&addr);
    // Callback.
    index = emberGpSinkTableLookup(&addr);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &index);
    break;
  }

  case EZSP_GP_SINK_TABLE_REMOVE_ENTRY: {
    // Command arguments.
    uint8_t sinkIndex;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &sinkIndex);
    // Callback.
    emberGpSinkTableRemoveEntry(sinkIndex);
    break;
  }

  case EZSP_GP_SINK_TABLE_SET_ENTRY: {
    // Command arguments.
    uint8_t sinkIndex;
    EmberGpSinkTableEntry entry;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &sinkIndex);
    fetchEmberGpSinkTableEntry(&entry);
    // Callback.
    status = emberGpSinkTableSetEntry(sinkIndex,
                                      &entry);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

// -----------------------------------------------------------------------------
// Binding Frames

  case EZSP_BINDING_IS_ACTIVE: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    bool active;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    active = emberBindingIsActive(index);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &active);
    break;
  }

  case EZSP_CLEAR_BINDING_TABLE: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberClearBindingTable();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_DELETE_BINDING: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberAfEzspDeleteBindingCommandCallback(index);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_GET_BINDING: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberStatus status;
    EmberBindingTableEntry value;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    status = emberGetBinding(index,
                             &value);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberBindingTableEntry(&value);
    break;
  }

  case EZSP_GET_BINDING_REMOTE_NODE_ID: {
    // Command arguments.
    uint8_t index;
    // Response arguments.
    EmberNodeId nodeId;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    // Callback.
    nodeId = emberGetBindingRemoteNodeId(index);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "v",
                      &nodeId);
    break;
  }

  case EZSP_SET_BINDING: {
    // Command arguments.
    uint8_t index;
    EmberBindingTableEntry value;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &index);
    fetchEmberBindingTableEntry(&value);
    // Callback.
    status = emberAfEzspSetBindingCommandCallback(index,
                                                  &value);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_BINDING_REMOTE_NODE_ID: {
    // Command arguments.
    uint8_t index;
    EmberNodeId nodeId;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "uv",
                      &index,
                      &nodeId);
    // Callback.
    emberSetBindingRemoteNodeId(index,
                                nodeId);
    break;
  }

// -----------------------------------------------------------------------------
// Mfglib

  case EZSP_MFGLIB_END: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = mfglibEnd();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MFGLIB_GET_CHANNEL: {
    // Response arguments.
    uint8_t channel;
    // Callback.
    channel = mfglibGetChannel();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &channel);
    break;
  }

  case EZSP_MFGLIB_GET_POWER: {
    // Response arguments.
    int8_t power;
    // Callback.
    power = mfglibGetPower();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "s",
                      &power);
    break;
  }

  case EZSP_MFGLIB_SEND_PACKET: {
    // Command arguments.
    uint8_t packetLength;
    uint8_t* packetContents;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "up",
                      &packetLength,
                      &packetContents,
                      &packetLength);
    // Callback.
    status = emberAfEzspMfglibSendPacketCommandCallback(packetLength,
                                                        packetContents);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MFGLIB_SET_CHANNEL: {
    // Command arguments.
    uint8_t channel;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &channel);
    // Callback.
    status = mfglibSetChannel(channel);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MFGLIB_SET_POWER: {
    // Command arguments.
    uint16_t txPowerMode;
    int8_t power;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "vs",
                      &txPowerMode,
                      &power);
    // Callback.
    status = mfglibSetPower(txPowerMode,
                            power);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MFGLIB_START: {
    // Command arguments.
    bool rxCallback;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &rxCallback);
    // Callback.
    status = emberAfEzspMfglibStartCommandCallback(rxCallback);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MFGLIB_START_STREAM: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = mfglibStartStream();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MFGLIB_START_TONE: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = mfglibStartTone();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MFGLIB_STOP_STREAM: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = mfglibStopStream();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_MFGLIB_STOP_TONE: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = mfglibStopTone();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

// -----------------------------------------------------------------------------
// Certificate Based Key Exchange (CBKE)

  case EZSP_CALCULATE_SMACS: {
    // Command arguments.
    bool amInitiator;
    EmberCertificateData partnerCertificate;
    EmberPublicKeyData partnerEphemeralPublicKey;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &amInitiator);
    fetchEmberCertificateData(&partnerCertificate);
    fetchEmberPublicKeyData(&partnerEphemeralPublicKey);
    // Callback.
    status = emberCalculateSmacs(amInitiator,
                                 &partnerCertificate,
                                 &partnerEphemeralPublicKey);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_CALCULATE_SMACS283K1: {
    // Command arguments.
    bool amInitiator;
    EmberCertificate283k1Data partnerCertificate;
    EmberPublicKey283k1Data partnerEphemeralPublicKey;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &amInitiator);
    fetchEmberCertificate283k1Data(&partnerCertificate);
    fetchEmberPublicKey283k1Data(&partnerEphemeralPublicKey);
    // Callback.
    status = emberCalculateSmacs283k1(amInitiator,
                                      &partnerCertificate,
                                      &partnerEphemeralPublicKey);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_CLEAR_TEMPORARY_DATA_MAYBE_STORE_LINK_KEY: {
    // Command arguments.
    bool storeLinkKey;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &storeLinkKey);
    // Callback.
    status = emberClearTemporaryDataMaybeStoreLinkKey(storeLinkKey);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_CLEAR_TEMPORARY_DATA_MAYBE_STORE_LINK_KEY283K1: {
    // Command arguments.
    bool storeLinkKey;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "u",
                      &storeLinkKey);
    // Callback.
    status = emberClearTemporaryDataMaybeStoreLinkKey283k1(storeLinkKey);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_DSA_SIGN: {
    // Command arguments.
    uint8_t messageLength;
    uint8_t* messageContents;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    emAfFetchOrAppend(true /* FETCH */,
                      "up",
                      &messageLength,
                      &messageContents,
                      &messageLength);
    // Callback.
    status = emberAfEzspDsaSignCommandCallback(messageLength,
                                               messageContents);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_DSA_VERIFY: {
    // Command arguments.
    EmberMessageDigest digest;
    EmberCertificateData signerCertificate;
    EmberSignatureData receivedSig;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberMessageDigest(&digest);
    fetchEmberCertificateData(&signerCertificate);
    fetchEmberSignatureData(&receivedSig);
    // Callback.
    status = emberDsaVerify(&digest,
                            &signerCertificate,
                            &receivedSig);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_DSA_VERIFY283K1: {
    // Command arguments.
    EmberMessageDigest digest;
    EmberCertificate283k1Data signerCertificate;
    EmberSignature283k1Data receivedSig;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberMessageDigest(&digest);
    fetchEmberCertificate283k1Data(&signerCertificate);
    fetchEmberSignature283k1Data(&receivedSig);
    // Callback.
    status = emberDsaVerify283k1(&digest,
                                 &signerCertificate,
                                 &receivedSig);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_GENERATE_CBKE_KEYS: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberGenerateCbkeKeys();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_GENERATE_CBKE_KEYS283K1: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberGenerateCbkeKeys283k1();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_GET_CERTIFICATE: {
    // Response arguments.
    EmberStatus status;
    EmberCertificateData localCert;
    // Callback.
    status = emberGetCertificate(&localCert);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberCertificateData(&localCert);
    break;
  }

  case EZSP_GET_CERTIFICATE283K1: {
    // Response arguments.
    EmberStatus status;
    EmberCertificate283k1Data localCert;
    // Callback.
    status = emberGetCertificate283k1(&localCert);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    appendEmberCertificate283k1Data(&localCert);
    break;
  }

  case EZSP_SAVE_PREINSTALLED_CBKE_DATA283K1: {
    // Response arguments.
    EmberStatus status;
    // Callback.
    status = emberAfEzspSavePreinstalledCbkeData283k1CommandCallback();
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  case EZSP_SET_PREINSTALLED_CBKE_DATA: {
    // Command arguments.
    EmberPublicKeyData caPublic;
    EmberCertificateData myCert;
    EmberPrivateKeyData myKey;
    // Response arguments.
    EmberStatus status;
    // Fetch.
    fetchEmberPublicKeyData(&caPublic);
    fetchEmberCertificateData(&myCert);
    fetchEmberPrivateKeyData(&myKey);
    // Callback.
    status = emberSetPreinstalledCbkeData(&caPublic,
                                          &myCert,
                                          &myKey);
    // Append.
    emAfFetchOrAppend(false /* APPEND */,
                      "u",
                      &status);
    break;
  }

  default: return false;
  }

  return true;
}
